<?xml version="1.0" encoding="UTF-8" ?>
<class name="SteamServer" inherits="Object" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../doc/class.xsd">
	<brief_description>
		An ecosystem of tools for Godot Engine and Valve's Steam.
	</brief_description>
	<description>
		Full documentation and tutorials are available at https://godotsteam.com/.
	</description>
	<tutorials>
		<link title="Achievement Icons">https://godotsteam.com/tutorials/achievement_icons/</link>
		<link title="Authentication">https://godotsteam.com/tutorials/authentication/</link>
		<link title="Auto-Matchmaking">https://godotsteam.com/tutorials/auto_matchmaking/</link>
		<link title="Avatars">https://godotsteam.com/tutorials/avatars/</link>
		<link title="C#">https://godotsteam.com/tutorials/c-sharp/</link>
		<link title="Common Issues">https://godotsteam.com/tutorials/common_issues/</link>
		<link title="Exporting and Shipping">https://godotsteam.com/tutorials/exporting_shipping/</link>
		<link title="Friends' Lobbies">https://godotsteam.com/tutorials/friends_lobbies/</link>
		<link title="Initializing Steam">https://godotsteam.com/tutorials/initializing/</link>
		<link title="Leaderboards">https://godotsteam.com/tutorials/leaderboards/</link>
		<link title="Linux Caveats">https://godotsteam.com/tutorials/linux_caveats/</link>
		<link title="Lobbies">https://godotsteam.com/tutorials/lobbies/</link>
		<link title="Mac Caveats">https://godotsteam.com/tutorials/mac_caveats/</link>
		<link title="Mac Exporting">https://godotsteam.com/tutorials/mac_export/</link>
		<link title="P2P Networking">https://godotsteam.com/tutorials/p2p/</link>
		<link title="Remove Steam">https://godotsteam.com/tutorials/remove_steam/</link>
		<link title="Rich Presence">https://godotsteam.com/tutorials/rich_presence/</link>
		<link title="Stats and Achievements">https://godotsteam.com/tutorials/stats_achievements/</link>
		<link title="Workshop">https://godotsteam.com/tutorials/workshop/</link>
	</tutorials>
	<methods>
		<method name="acceptConnection">
			<return type="int" />
			<param index="0" name="connection_handle" type="int" />
			<description>
				Accept an incoming connection that has been received on a listen socket.
			</description>
		</method>
		<method name="acceptP2PSessionWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				This allows the game to specify accept an incoming packet. This needs to be called before a real connection is established to a remote host, the game will get a chance to say whether or not the remote user is allowed to talk to them.
				When a remote user that you haven't sent a packet to recently, tries to first send you a packet, your game will receive a callback [signal SteamServer.p2p_session_request]. This callback contains the Steam ID of the user who wants to send you a packet. In response to this callback, you'll want to see if it's someone you want to talk to (for example, if they're in a lobby with you), and if so, accept the connection; otherwise if you don't want to talk to the user, just ignore the request. If the user continues to send you packets, another [signal SteamServer.p2p_session_request] will be posted periodically. If you've called [method SteamServer.sendP2PPacket] on the other user, this implicitly accepts the session request.
				[b]Note:[/b] This call should only be made in response to a [signal SteamServer.p2p_session_request] callback.
			</description>
		</method>
		<method name="acceptSessionWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Call this in response to a [signal SteamServer.network_messages_session_request] callback. [signal SteamServer.network_messages_session_request] callbacks are posted when a user tries to send you a message, and you haven't tried to talk to them first. If you don't want to talk to them, just ignore the request. If the user continues to send you messages, [signal SteamServer.network_messages_session_request] callbacks will continue to be posted periodically.
				Returns false if there is no session with the user pending or otherwise. If there is an existing active session, this function will return true, even if it is not pending.
				Calling [method SteamServer.sendMessageToUser] will implicitly accepts any pending session request to that user.
			</description>
		</method>
		<method name="addAppDependency">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="app_id" type="int" />
			<description>
				Adds a dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method  SteamServer.getAppDependencies]. This is a soft-dependency that is displayed on the web. It is up to the application to determine whether the item can actually be used or not.
				Triggers a [signal SteamServer.add_app_dependency_result] callback.
			</description>
		</method>
		<method name="addContentDescriptor">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="descriptor_id" type="int" />
			<description>
				Add a content descriptor to a piece of UGC.
				[b]Note:[/b] Valve has no documentation on this function currently.
			</description>
		</method>
		<method name="addDependency">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="child_published_file_id" type="int" />
			<description>
				Adds a workshop item as a dependency to the specified item. If the published_file_id item is of type k_EWorkshopFileTypeCollection (2), than the child_published_file_id is simply added to that collection. Otherwise, the dependency is a soft one that is displayed on the web and can be retrieved via the ISteamUGC API using a combination of the numChildren key returned from [method SteamServer.getQueryUGCResult] and [method SteamServer.getQueryUGCChildren].
				Triggers a [signal SteamServer.add_ugc_dependency_result] callback.
			</description>
		</method>
		<method name="addExcludedTag">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="tag_name" type="String" />
			<description>
				Adds a excluded tag to a pending UGC Query. This will only return UGC without the specified tag.
				[b]Note:[/b] This must be set before you send a UGC Query handle using [method SteamServer.sendQueryUGCRequest].
			</description>
		</method>
		<method name="addIPAddress">
			<return type="bool" />
			<param index="0" name="reference_name" type="String" />
			<description>
				Add a new IP address struct and store it for use. When this networking IP address is used in other functions, you will always use the [b]reference_name[/b] to use this struct.
			</description>
		</method>
		<method name="addIdentity">
			<return type="bool" />
			<param index="0" name="reference_name" type="String" />
			<description>
				Create a new network identity struct and store it for use. When this network identity is used in other functions, you will always use the reference_name to use this struct.
				You will have to set the IP, Steam ID, string, or bytes with other functions below otherwise the identity is invalid.
			</description>
		</method>
		<method name="addItemKeyValueTag">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="key" type="String" />
			<param index="2" name="value" type="String" />
			<description>
				Adds a key-value tag pair to an item. Keys can map to multiple different values (1-to-many relationship).
				Key names are restricted to alpha-numeric characters and the '_' character.
				Both keys and values cannot exceed 255 characters in length.
				Key-value tags are searchable by exact match only.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="addItemPreviewFile">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="preview_file" type="String" />
			<param index="2" name="type" type="int" enum="ItemPreviewType" />
			<description>
				Adds an additional preview file for the item.
				Then the format of the image should be one that both the web and the application (if necessary) can render, and must be under 1MB. Suggested formats include JPG, PNG and GIF.
				[b]Note:[/b] Using 1 or 2 in type are not currently supported with this API. For YouTube videos you should use [method SteamServer.addItemPreviewVideo].
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="addItemPreviewVideo">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="video_id" type="String" />
			<description>
				Adds an additional video preview from YouTube for the item.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [submitItemUpdate](/functions/ugc/#submititemupdate).
			</description>
		</method>
		<method name="addItemToFavorites">
			<return type="void" />
			<param index="0" name="app_id" type="int" />
			<param index="1" name="published_file_id" type="int" />
			<description>
				Adds a workshop item to the users favorites list.
				Triggers a [signal SteamServer.user_favorite_items_list_changed] callback.
			</description>
		</method>
		<method name="addPromoItem">
			<return type="int" />
			<param index="0" name="item" type="int" />
			<description>
				Grant a specific one-time promotional item to the current user.
				This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. This can be useful if your game has custom UI for showing a specific promo item to the user otherwise if you want to grant multiple promotional items then use [method SteamServer.addPromoItems] or [method SteamServer.grantPromoItems].
				Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app IDs that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
			</description>
		</method>
		<method name="addPromoItems">
			<return type="int" />
			<param index="0" name="items" type="PackedInt64Array" />
			<description>
				Grant a specific one-time promotional item to the current user.
				This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant a single promotional item then use [method SteamServer.addPromoItems]. If you want to grant all possible promo items then use [method SteamServer.grantPromoItems].
				Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
			</description>
		</method>
		<method name="addRequiredKeyValueTag">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="key" type="String" />
			<param index="2" name="value" type="String" />
			<description>
				Adds a required key-value tag to a pending UGC Query. This will only return workshop items that have a key and a value.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="addRequiredTag">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="tag_name" type="String" />
			<description>
				Adds a required tag to a pending UGC Query. This will only return UGC with the specified tag.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="addRequiredTagGroup">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="tag_array" type="Array" />
			<description>
				Adds the requirement that the returned items from the pending UGC Query have at least one of the tags in the given set (logical "or"). For each tag group that is added, at least one tag from each group is required to be on the matching items.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="allowP2PPacketRelay">
			<return type="bool" />
			<param index="0" name="allow" type="bool" />
			<description>
				Allow or disallow P2P connections to fall back to being relayed through the Steam servers if a direct connection or NAT-traversal cannot be established.
				This only applies to connections created after setting this value, or to existing connections that need to automatically reconnect after this value is set.
				P2P packet relay is allowed by default.
			</description>
		</method>
		<method name="associateWithClan">
			<return type="void" />
			<param index="0" name="clan_id" type="int" />
			<description>
				Associate this game server with this clan for the purposes of computing player compatibility.
			</description>
		</method>
		<method name="beginAsyncRequestFakeIP">
			<return type="bool" />
			<param index="0" name="num_ports" type="int" />
			<description>
				Begin asynchronous process of allocating a fake IPv4 address that other peers can use to contact us via P2P. IP addresses returned by this function are globally unique for a given app ID.
				Triggers a [sgnal SteamServer.fake_ip_result] callback.
				False if a request was already in progress, true if a new request was started.
			</description>
		</method>
		<method name="beginAuthSession">
			<return type="int" enum="BeginAuthSessionResult" />
			<param index="0" name="ticket" type="PackedByteArray" />
			<param index="1" name="ticket_size" type="int" />
			<param index="2" name="steam_id" type="int" />
			<description>
				Authenticate the ticket from the entity Steam ID to be sure it is valid and isn't reused.
				The ticket is created on the entity with [method SteamServer.getAuthSessionTicket] and then needs to be provided over the network for the other end to validate.
				This registers for [signal SteamServer.validate_auth_ticket_response] callbacks if the entity goes offline or cancels the ticket.
				When the multiplayer session terminates you must call [method SteamServer.endAuthSession]
				Trigger a [signal SteamServer.validate_auth_ticket_response] callback.
			</description>
		</method>
		<method name="cancelAuthTicket">
			<return type="void" />
			<param index="0" name="auth_ticket" type="int" />
			<description>
				Cancels an auth ticket received from [method Steama.getAuthSessionTicket]. This should be called when no longer playing with the specified entity.
			</description>
		</method>
		<method name="checkPingDataUpToDate">
			<return type="bool" />
			<param index="0" name="max_age_in_seconds" type="float" />
			<description>
				Check if the ping data of sufficient recency is available, and if it's too old, start refreshing it.
				Please only call this function when you really do need to force an immediate refresh of the data. (For example, in response to a specific user input to refresh this information.) Don't call it "just in case", before every connection, etc. That will cause extra traffic to be sent for no benefit. The library will automatically refresh the information as needed.
				True if sufficiently recent data is already available. False if sufficiently recent data is not available. In this case, ping measurement is initiated, if it is not already active. (You cannot restart a measurement already in progress.)
			</description>
		</method>
		<method name="checkResultSteamID">
			<return type="bool" />
			<param index="0" name="steam_id_expected" type="int" />
			<param index="1" name="this_inventory_handle" type="int" default="0" />
			<description>
				Checks whether an inventory result handle belongs to the specified Steam ID. This is important when using [method SteamServer.deserializeResult], to verify that a remote player is not pretending to have a different user's inventory.
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="clearAllKeyValues">
			<return type="void" />
			<description>
				Clears the whole list of key/values that are sent in rules queries.
			</description>
		</method>
		<method name="clearIPAddress">
			<return type="void" />
			<param index="0" name="reference_name" type="String" />
			<description>
				IP Address - Set everything to zero. E.g. [::]:0.
			</description>
		</method>
		<method name="clearIdentity">
			<return type="void" />
			<param index="0" name="reference_name" type="String" />
			<description>
				Clear a network identity's data.
			</description>
		</method>
		<method name="clearUserAchievement">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Resets the unlock status of an achievement for the specified user.
				This is primarily only ever used for testing.
				You must have called [method SteamServer.requestUserStats] and it needs to return successfully via its callback prior to calling this!
				This call only modifies Steam's in-memory state and is very cheap. To submit the stats to the server you must call [method SteamServer.storeUserStats].
				[b]Note:[/b] This will work only on achievements that game servers are allowed to set. If the "Set By" field for this achievement is "Official GS" then only game servers that have been declared as officially controlled by you will be able to set it. To do this you must set the IP range of your official servers in the Dedicated Servers section of App Admin.
			</description>
		</method>
		<method name="closeChannelWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="channel" type="int" />
			<description>
				Call this when you're done talking to a user on a specific channel. Once all open channels to a user have been closed, the open session to the user will be closed, and any new data from this user will trigger a [signal SteamServer.network_messages_session_request] callback.
			</description>
		</method>
		<method name="closeConnection">
			<return type="bool" />
			<param index="0" name="peer" type="int" />
			<param index="1" name="reason" type="int" />
			<param index="2" name="debug_message" type="String" />
			<param index="3" name="linger" type="bool" />
			<description>
				Disconnects from the remote host and invalidates the connection handle. Any unread data on the connection is discarded.
				[b]reason[/b] is an application defined code that will be received on the other end and recorded (when possible) in backend analytics. The value should come from a restricted range. (See ESteamNetConnectionEnd.) If you don't need to communicate any information to the remote host, and do not want analytics to be able to distinguish "normal" connection terminations from "exceptional" ones, you may pass zero, in which case the generic value of CONNECTION_END_APP_MIN will be used.
				[b]debug_message[/b] is an optional human-readable diagnostic string that will be received by the remote host and recorded (when possible) in backend analytics.
			</description>
		</method>
		<method name="closeListenSocket">
			<return type="bool" />
			<param index="0" name="socket" type="int" />
			<description>
				Destroy a listen socket. All the connections that were accepted on the listen socket are closed ungracefully.
			</description>
		</method>
		<method name="closeP2PChannelWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="channel" type="int" />
			<description>
				Closes a P2P channel when you're done talking to a user on the specific channel.
				Once all channels to a user have been closed, the open session to the user will be closed and new data from this user will trigger a new [signal SteamServer.p2p_session_request] callback.
			</description>
		</method>
		<method name="closeP2PSessionWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				This should be called when you're done communicating with a user, as this will free up all of the resources allocated for the connection under-the-hood.
				If the remote user tries to send data to you again, a new [signal SteamServer.p2p_session_request] callback will be posted.
			</description>
		</method>
		<method name="closeSessionWithUser">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Call this when you're done talking to a user to immediately free up resources under-the-hood. If the remote user tries to send data to you again, another [signal SteamServer.network_messages_session_request] callback will be posted.
				[b]Note:[/b] sessions that go unused for a few minutes are automatically timed out.
			</description>
		</method>
		<method name="computeNewPlayerCompatibility">
			<return type="void" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Checks if any of the current players don't want to play with this new player that is attempting to join - or vice versa; based on the frenemy system.
			</description>
		</method>
		<method name="configureConnectionLanes">
			<return type="int" />
			<param index="0" name="connection" type="int" />
			<param index="1" name="lanes" type="int" />
			<param index="2" name="priorities" type="Array" />
			<param index="3" name="weights" type="Array" />
			<description>
				Configure multiple outbound messages streams ("lanes") on a connection, and control head-of-line blocking between them. Messages within a given lane are always sent in the order they are queued, but messages from different lanes may be sent out of order. Each lane has its own message number sequence. The first message sent on each lane will be assigned the number 1.
				Each lane has a "priority". Lower priority lanes will only be processed when all higher-priority lanes are empty. The magnitudes of the priority values are not relevant, only their sort order. Higher numeric values take priority over lower numeric values.
				Each lane also is assigned a weight, which controls the approximate proportion of the bandwidth that will be consumed by the lane, relative to other lanes of the same priority. (This is assuming the lane stays busy. An idle lane does not build up "credits" to be be spent once a message is queued.) This value is only meaningful as a proportion, relative to other lanes with the same priority. For lanes with different priorities, the strict priority order will prevail, and their weights relative to each other are not relevant. Thus, if a lane has a unique priority value, the weight value for that lane is not relevant.
			</description>
		</method>
		<method name="connectByIPAddress">
			<return type="int" />
			<param index="0" name="ip_address_with_port" type="String" />
			<param index="1" name="options" type="Dictionary" />
			<description>
				Begin connecting to a server listen socket that is identified using an [ip-address]:[port], i.e. 127.0.0.1:27015. Used with [method SteamServer.createListenSocketIP].
			</description>
		</method>
		<method name="connectP2P">
			<return type="int" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="virtual_port" type="int" />
			<param index="2" name="options" type="Dictionary" />
			<description>
				Begin connecting to a server that is identified using a platform-specific identifier. This uses the default rendezvous service, which depends on the platform and library configuration. (E.g. on Steam, it goes through the steam backend.) The traffic is relayed over the Steam Datagram Relay network.
				If you use this, you probably want to call initRelayNetworkAccess when your app initializes. If you need to set any initial config options, pass them here.
				See SteamNetworkingConfigValue_t for more about why this is preferable to setting the options "immediately" after creation.
				Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
				Alternately you can pass an empty array.
			</description>
		</method>
		<method name="connectToHostedDedicatedServer">
			<return type="int" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="virtual_port" type="int" />
			<param index="2" name="options" type="Dictionary" />
			<description>
				Client call to connect to a server hosted in a Valve data center, on the specified virtual port. You must have placed a ticket for this server into the cache, or else this connect attempt will fail!
				Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
				Alternately you can pass an empty array.
			</description>
		</method>
		<method name="consumeItem">
			<return type="int" />
			<param index="0" name="item_consume" type="int" />
			<param index="1" name="quantity" type="int" />
			<description>
				Consumes items from a user's inventory. If the quantity of the given item goes to zero, it is permanently removed.
				Once an item is removed it cannot be recovered. This is not for the faint of heart - if your game implements item removal at all, a high-friction UI confirmation process is highly recommended.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="convertPingLocationToString">
			<return type="String" />
			<param index="0" name="location" type="PackedByteArray" />
			<description>
				Convert a ping location into a text format suitable for sending over the wire. The format is a compact and human readable. However, it is subject to change so please do not parse it yourself.
			</description>
		</method>
		<method name="createCookieContainer">
			<return type="int" />
			<param index="0" name="allow_response_to_modify" type="bool" />
			<description>
				Creates a cookie container to store cookies during the lifetime of the process. This API is just for during process lifetime, after Steam restarts no cookies are persisted and you have no way to access the cookie container across repeat executions of your process.
				If allow_responses_to_modify is true then any response to your requests using this cookie container may add new cookies to the container which may be transmitted with future requests. Otherwise, if it's false then only cookies you explicitly set will be sent.
				You can associate the cookie container with a http request by using [method SteamServer.setHTTPRequestCookieContainer], and you can set a cookie using [method SteamServer.setCookie]. Don't forget to free the container when you're done with it to prevent leaking memory by calling [method SteamServer.releaseCookieContainer]!
			</description>
		</method>
		<method name="createFakeUDPPort">
			<return type="void" />
			<param index="0" name="fake_server_port" type="int" />
			<description>
				Get an interface that can be used like a UDP port to send/receive datagrams to a FakeIP address. This is intended to make it easy to port existing UDP-based code to take advantage of SDR.
				[b]fake_server_port[/b] refers to the index of the port allocated using [method SteamServer.beginAsyncRequestFakeIP] and is used to create "server" ports. You may call this before the allocation has completed. However, any attempts to send packets will fail until the allocation has succeeded. When the peer receives packets sent from this interface, the from address of the packet will be the globally-unique FakeIP. If you call this function multiple times and pass the same (nonnegative) fake port index, the same object will be returned, and this object is not reference counted.
				To create a "client" port (e.g. the equivalent of an ephemeral UDP port) pass -1. In this case, a distinct object will be returned for each call. When the peer receives packets sent from this interface, the peer will assign a FakeIP from its own locally-controlled namespace.
			</description>
		</method>
		<method name="createHTTPRequest">
			<return type="int" />
			<param index="0" name="request_method" type="int" enum="HTTPMethod" />
			<param index="1" name="absolute_url" type="String" />
			<description>
				Initializes a new HTTP request. Requires the method such as GET or POST and the absolute URL for the request. Both http and https are supported, so this string must start with "http://" or "https://" and should look like "http://store.steampowered.com/app/10/" or similar. This call returns a handle that you can use to make further calls to setup and then send the HTTP request with [method SteamServer.sendHTTPRequest] or [method SteamServer.sendHTTPRequestAndStreamResponse]. Don't forget to free the HTTP request when you're done with it to prevent leaking memory by calling [method SteamServer.releaseHTTPRequest].
			</description>
		</method>
		<method name="createHostedDedicatedServerListenSocket">
			<return type="int" />
			<param index="0" name="virtual_port" type="int" />
			<param index="1" name="options" type="Dictionary" />
			<description>
				Create a listen socket on the specified virtual port. The physical UDP port to use will be determined by the SDR_LISTEN_PORT environment variable. If a UDP port is not configured, this call will fail.
				This function should be used when you are using the ticket generator library to issue your own tickets. Clients connecting to the server on this virtual port will need a ticket, and they must connect using [method SteamServer.connectToHostedDedicatedServer].
				Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
				Alternately you can pass an empty array.
			</description>
		</method>
		<method name="createItem">
			<return type="void" />
			<param index="0" name="app_id" type="int" />
			<param index="1" name="file_type" type="int" enum="WorkshopFileType" />
			<description>
				Creates a new workshop item with no content attached yet.
				Triggers a [signal SteamServer.item_created] callback.
			</description>
		</method>
		<method name="createListenSocketIP">
			<return type="int" />
			<param index="0" name="ip_reference" type="String" />
			<param index="1" name="options" type="Dictionary" />
			<description>
				Creates a "server" socket that listens for clients to connect to by calling [method SteamServer.connectByIPAddress], over ordinary UDP (IPv4 or IPv6)
				Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
				Alternately you can pass an empty array.
			</description>
		</method>
		<method name="createListenSocketP2P">
			<return type="int" />
			<param index="0" name="virtual_port" type="int" />
			<param index="1" name="options" type="Dictionary" />
			<description>
				Create a listen socket that will listen for P2P connections sent to our FakeIP.  A peer can initiate connections to this listen socket by calling [method SteamServer.connectByIPAddress].
			</description>
		</method>
		<method name="createListenSocketP2PFakeIP">
			<return type="int" />
			<param index="0" name="fake_port" type="int" />
			<param index="1" name="options" type="Dictionary" />
			<description>
				Like [method SteamServer.createListenSocketIP], but clients will connect using [method SteamServer.connectP2P]. The connection will be relayed through the Valve network.
				[b]virtual_port[/b] specifies how clients can connect to this socket using [method SteamServer.connectP2P]. It's very common for applications to only have one listening socket; in that case, use zero. If you need to open multiple listen sockets and have clients be able to connect to one or the other, then virtual_port should be a small integer (less than 1000) unique to each listen socket you create.
				Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
				Alternately you can pass an empty array.
			</description>
		</method>
		<method name="createPollGroup">
			<return type="int" />
			<description>
				Create a new poll group.
				You should destroy the poll group when you are done using [method SteamServer.destroyPollGroup].
			</description>
		</method>
		<method name="createQueryAllUGCRequest">
			<return type="int" />
			<param index="0" name="query_type" type="int" enum="UGCQuery" />
			<param index="1" name="matching_type" type="int" enum="UGCMatchingUGCType" />
			<param index="2" name="creator_id" type="int" />
			<param index="3" name="consumer_id" type="int" />
			<param index="4" name="page" type="int" />
			<description>
				Query for all matching UGC. You can use this to list all of the available UGC for your app.
				This will return up to 50 results. You can make subsequent calls to this function, increasing the page each time to get the next set of results.
				To query for the UGC associated with a single user you can use [method SteamServer.createQueryUserUGCRequest] instead.
				[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
				[b]Note:[/b] You must release the handle returned by this function by calling [method SteamServer.releaseQueryUGCRequest] when you are done with it.
			</description>
		</method>
		<method name="createQueryUGCDetailsRequest">
			<return type="int" />
			<param index="0" name="published_file_id" type="Array" />
			<description>
				Query for the details of specific workshop items.
				This will return up to 50 results.
				To query all the UGC for your app you can use [method SteamServer.createQueryAllUGCRequest] instead.
				[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
				[b]Note:[/b] You must release the handle returned by this function by calling [method SteamServer.releaseQueryUGCRequest] when you are done with it.
			</description>
		</method>
		<method name="createQueryUserUGCRequest">
			<return type="int" />
			<param index="0" name="account_id" type="int" />
			<param index="1" name="list_type" type="int" enum="UserUGCList" />
			<param index="2" name="matching_ugc_type" type="int" enum="UGCMatchingUGCType" />
			<param index="3" name="sort_order" type="int" enum="UserUGCListSortOrder" />
			<param index="4" name="creator_id" type="int" />
			<param index="5" name="consumer_id" type="int" />
			<param index="6" name="page" type="int" />
			<description>
				Query UGC associated with a user. You can use this to list the UGC the user is subscribed to amongst other things.
				This will return up to 50 results.
				To query all the UGC for your app you can use [method SteamServer.createQueryAllUGCRequest] instead.
				[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
				[b]Note:[/b] You must release the handle returned by this function by calling [method SteamServer.releaseQueryUGCRequest] when you are done with it.
			</description>
		</method>
		<method name="createSocketPair">
			<return type="Dictionary" />
			<param index="0" name="loopback" type="bool" />
			<param index="1" name="remote_steam_id1" type="int" />
			<param index="2" name="remote_steam_id2" type="int" />
			<description>
				Create a pair of connections that are talking to each other, e.g. a loopback connection. This is very useful for testing, or so that your client/server code can work the same even when you are running a local "server".
				The two connections will immediately be placed into the connected state, and no callbacks will be posted immediately. After this, if you close either connection, the other connection will receive a callback, exactly as if they were communicating over the network. You must close both sides in order to fully clean up the resources!
				By default, internal buffers are used, completely bypassing the network, the chopping up of messages into packets, encryption, copying the payload, etc. This means that loopback packets, by default, will not simulate lag or loss. Passing true for loopback will cause the socket pair to send packets through the local network loopback device (127.0.0.1) on ephemeral ports. Fake lag and loss are supported in this case, and CPU time is expended to encrypt and decrypt.
				If you wish to assign a specific identity to either connection, you may pass a particular identity. Otherwise, if you pass nullptr, the respective connection will assume a generic "localhost" identity. If you use real network loopback, this might be translated to the actual bound loopback port. Otherwise, the port will be zero.
				The returned dictionary contains the following keys: [b]success (bool), connection1 (int), and connection2 (int).[/b]
			</description>
		</method>
		<method name="deferHTTPRequest">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Defers a request which has already been sent by moving it at the back of the queue.
			</description>
		</method>
		<method name="deleteItem">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Deletes the item without prompting the user.
				Triggers a [signal SteamServer.item_deleted] callback.
			</description>
		</method>
		<method name="deserializeResult">
			<return type="int" />
			<param index="0" name="buffer" type="PackedByteArray" />
			<description>
				Deserializes a result set and verifies the signature bytes.
				This call has a potential soft-failure mode where the handle status is set to 27. [method SteamServer.getResultItems] will still succeed in this mode. The "expired" result could indicate that the data may be out of date - not just due to timed expiration (one hour), but also because one of the items in the result set may have been traded or consumed since the result set was generated. You could compare the timestamp from [method SteamServer.getResultTimestamp] to [method SteamServer.getServerRealTime] to determine how old the data is. You could simply ignore the "expired" result code and continue as normal, or you could request the player with expired data to send an updated result set.
				You should call [method SteamServer.checkResultSteamID] on the result handle when it completes to verify that a remote player is not pretending to have a different user's inventory.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
			</description>
		</method>
		<method name="destroyPollGroup">
			<return type="bool" />
			<param index="0" name="poll_group" type="int" />
			<description>
				Destroy a poll group created with [signal SteamServer.createPollGroup].
				If there are any connections in the poll group, they are removed from the group, and left in a state where they are not part of any poll group. Returns false if passed an invalid poll group handle.
			</description>
		</method>
		<method name="destroyResult">
			<return type="void" />
			<param index="0" name="this_inventory_handle" type="int" default="0" />
			<description>
				Destroys a result handle and frees all associated memory.
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="downloadItem">
			<return type="bool" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="high_priority" type="bool" />
			<description>
				Download new or update already installed item.
				If the return value is true then register and wait for the callback [signal SteamServer.item_downloaded] before calling [method SteamServer.getItemInstallInfo] or accessing the workshop item on disk.
				If the user is not subscribed to the item (e.g. a Game Server using anonymous login), the workshop item will be downloaded and cached temporarily.
				If the workshop item has an item state of 8, then this function can be called to initiate the update. Do not access the workshop item on disk until the callback [signal SteamServer.item_downloaded] is called.
			</description>
		</method>
		<method name="endAuthSession">
			<return type="void" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Ends an auth session that was started with [method SteamServer.beginAuthSession]. This should be called when no longer playing with the specified entity.
			</description>
		</method>
		<method name="estimatePingTimeBetweenTwoLocations">
			<return type="int" />
			<param index="0" name="location1" type="PackedByteArray" />
			<param index="1" name="location2" type="PackedByteArray" />
			<description>
				Estimate the round-trip latency between two arbitrary locations, in milliseconds. This is a conservative estimate, based on routing through the relay network. For most basic relayed connections, this ping time will be pretty accurate, since it will be based on the route likely to be actually used.
				If a direct IP route is used (perhaps via NAT traversal), then the route will be different, and the ping time might be better. Or it might actually be a bit worse! Standard IP routing is frequently suboptimal! But even in this case, the estimate obtained using this method is a reasonable upper bound on the ping time. (Also it has the advantage of returning immediately and not sending any packets.)
				In a few cases we might not able to estimate the route. In this case a negative value is returned. k_nSteamNetworkingPing_Failed means the reason was because of some networking difficulty. (Failure to ping, etc) k_nSteamNetworkingPing_Unknown is returned if we cannot currently answer the question for some other reason.
			</description>
		</method>
		<method name="estimatePingTimeFromLocalHost">
			<return type="int" />
			<param index="0" name="location" type="PackedByteArray" />
			<description>
				Same as [method SteamServer.estimatePingTimeBetweenTwoLocations], but assumes that one location is the local host. This is a bit faster, especially if you need to calculate a bunch of these in a loop to find the fastest one. In rare cases this might return a slightly different estimate than combining [method SteamServer.getLocalPingLocation] with [method SteamServer.estimatePingTimeBetweenTwoLocations]. That's because this function uses a slightly more complete set of information about what route would be taken.
			</description>
		</method>
		<method name="exchangeItems">
			<return type="int" />
			<param index="0" name="output_items" type="PackedInt64Array" />
			<param index="1" name="output_quantity" type="PackedInt32Array" />
			<param index="2" name="input_items" type="PackedInt64Array" />
			<param index="3" name="input_quantity" type="PackedInt32Array" />
			<description>
				Grant one item in exchange for a set of other items.
				This can be used to implement crafting recipes or transmutations, or items which unpack themselves into other items (e.g., a chest).
				The caller of this API passes in the requested item and an array of existing items and quantities to exchange for it. The API currently takes an array of items to generate but at this time the size of that array must be 1 and the quantity of the new item must be 1.
				Any items that can be granted must have an exchange attribute in their itemdef. The exchange attribute specifies a set of recipes that are valid exchanges for this item. Exchange recipes are evaluated atomically by the Inventory Service; if the supplied components do not match the recipe, or do not contain sufficient quantity, the exchange will fail.
				Will allow the item to be exchanged for either one #101 and one #102, five #103s or three #104s and three #105s. See the Steam Inventory Schema documentation for more details.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="flushMessagesOnConnection">
			<return type="int" />
			<param index="0" name="connection_handle" type="int" />
			<description>
				Flush any messages waiting on the Nagle timer and send them at the next transmission opportunity (often that means right now).
			</description>
		</method>
		<method name="generateItems">
			<return type="int" />
			<param index="0" name="items" type="PackedInt64Array" />
			<param index="1" name="quantity" type="PackedInt32Array" />
			<description>
				Grants specific items to the current user, for developers only.
				This API is only intended for prototyping - it is only usable by Steam accounts that belong to the publisher group for your game.
				You can pass in an array of items, identified by their item defintion int's and optionally a second array of corresponding quantities for each item. The length of these arrays _must match!
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="getAllItems">
			<return type="int" />
			<description>
				Start retrieving all items in the current users inventory.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] Calls to this function are subject to rate limits and may return cached results if called too frequently. It is suggested that you call this function only when you are about to display the user's full inventory, or if you expect that the inventory may have changed.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="getAppDependencies">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Get the app dependencies associated with the given published_file_id. These are "soft" dependencies that are shown on the web. It is up to the application to determine whether an item can be used or not.
				Triggers a [signal SteamServer.get_app_dependencies_result] callback.
			</description>
		</method>
		<method name="getAuthSessionTicket">
			<return type="Dictionary" />
			<param index="0" name="remote_steam_id" type="int" default="0" />
			<description>
				Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.
				After calling this you can send the ticket to the entity where they can then call [method SteamServer.beginAuthSession] to verify this entities integrity.
				When creating a ticket for use by the [method SteamServer.authenticateUserTicket] Web API, the calling application should wait for the [signal SteamServer.get_auth_session_ticket_response] callback generated by the API call before attempting to use the ticket to ensure that the ticket has been communicated to the server. If this callback does not come in a timely fashion (10 - 20 seconds), then your client is not connected to Steam, and the [method SteamServer.authenticateUserTicket] call will fail because it can not authenticate the user.
				Triggers a [signal SteamServer.get_auth_session_ticket_response] callback.
				[codeblock]
				The returned dicitonary contains the following keys:
				┠╴id (int)
				┠╴buffer (PackedByteArray)
				┖╴size (int)
				[/codeblock]
				[b]Note:[/b] As of Steamworks SDK 1.57, you need to pass a network identity that was created with our Networking Tools class.  However, this is optional and defaults to NULL.
			</description>
		</method>
		<method name="getAuthenticationStatus">
			<return type="int" enum="NetworkingAvailability" />
			<description>
				Query our readiness to participate in authenticated communications. A [signal SteamServer.network_authentication_status] callback is posted any time this status changes, but you can use this function to query it at any time.
			</description>
		</method>
		<method name="getAvailableP2PPacketSize">
			<return type="int" />
			<param index="0" name="channel" type="int" default="0" />
			<description>
				Calls [method SteamServer.isP2PPacketAvailable] under the hood, returns the size of the available packet or zero if there is no such packet.
			</description>
		</method>
		<method name="getCertificateRequest">
			<return type="Dictionary" />
			<description>
				Certificate provision by the application. On Steam, we normally handle all this automatically and you will not need to use these advanced functions.
				Get blob that describes a certificate request. You can send this to your game coordinator. Pass this blob to your game coordinator and call SteamDatagram_CreateCert.
				Returned dictionary contains the following keys: [b]certificate (int), cert_size (int), and error_message (string).[/b]
			</description>
		</method>
		<method name="getConfigValue">
			<return type="Dictionary" />
			<param index="0" name="config_value" type="int" enum="NetworkingConfigValue" />
			<param index="1" name="scope_type" type="int" enum="NetworkingConfigScope" />
			<param index="2" name="connection_handle" type="int" />
			<description>
				Get a configuration value.
				For values to pass to config_value, check the SDK's listing.
				For values to pass to scope_type, check the SDK's listing.
				Returned dictionary contains the following keys: [b]result (int), type (int), value (PackedByteArray), and buffer (int).[/b]
				The result key value may be one of the following: [b]-1 / bad value, -2 / bad connection handle, -3 / buffer too small, 1 / OK, or 2 / OK, inherited.[/b]
			</description>
		</method>
		<method name="getConfigValueInfo">
			<return type="Dictionary" />
			<param index="0" name="config_value" type="int" enum="NetworkingConfigValue" />
			<description>
				Returns info about a configuration value. For values to pass to config_value, check the SDK's listing. next_value can be used to iterate through all of the known configuration values.
				The returned dictionary contains the following keys: [b]type (int), scope (int), and next_value (int).[/b]
			</description>
		</method>
		<method name="getConnectionInfo">
			<return type="Dictionary" />
			<param index="0" name="connection_handle" type="int" />
			<description>
				Returns basic information about the high-level state of the connection. Returns false if the connection handle is invalid.
				The returned dictionary contains the following keys: [b]identity (string), user_data (int), listen_socket (int), remote_address (string), remote_pop (int), pop_relay (int), connection_state (int), end_reason (int), end_debug (string), and debug_description (string).[/b]
			</description>
		</method>
		<method name="getConnectionName">
			<return type="String" />
			<param index="0" name="peer" type="int" />
			<description>
				Fetch connection name into your buffer, which is at least nMaxLen bytes. Returns false if handle is invalid.
			</description>
		</method>
		<method name="getConnectionRealTimeStatus">
			<return type="Dictionary" />
			<param index="0" name="connection_handle" type="int" />
			<param index="1" name="lanes" type="int" />
			<param index="2" name="get_status" type="bool" default="true" />
			<description>
				Returns a small set of information about the real-time state of the connection and the queue status of each lane.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴connection_status (dictionary)
				    ┠╴state (int)
				    ┠╴ping (int)
				    ┠╴local_quality (float)
				    ┠╴remote_quality (float)
				    ┠╴packets_out_per_second (float)
				    ┠╴bytes_out_per_second (float)
				    ┠╴packets_in_per_second (float)
				    ┠╴bytes_in_per_second (float)
				    ┠╴send_rate (int)
				    ┠╴pending_unreliable (int)
				    ┠╴pending_reliable (int)
				    ┠╴send_unacknowledged_reliable (int)
				    ┖╴queue_time (int)
				┖╴lanes_status (array)
				    ┖╴lane_status (dictionary)
				        ┠╴pending_unreliable (int)
				        ┠╴pending_reliable (int)
				        ┠╴sent_unacknowledged_reliatble (int)
				        ┖╴queue_time (int)
				[/codeblock]
			</description>
		</method>
		<method name="getConnectionUserData">
			<return type="int" />
			<param index="0" name="peer" type="int" />
			<description>
				Fetch connection user data. Returns -1 if handle is invalid or if you haven't set any userdata on the connection.
			</description>
		</method>
		<method name="getDetailedConnectionStatus">
			<return type="Dictionary" />
			<param index="0" name="connection_handle" type="int" />
			<description>
				Returns very detailed connection stats in diagnostic text format. Useful for dumping to a log, etc. The format of this information is subject to change.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴success (int)
				┖╴buffer (string)
				[/codeblock]
			</description>
		</method>
		<method name="getDirectPingToPOP">
			<return type="int" />
			<param index="0" name="pop_id" type="int" />
			<description>
				Get direct ping time to the relays at the point of presence.
			</description>
		</method>
		<method name="getFakeIP">
			<return type="Dictionary" />
			<param index="0" name="first_port" type="int" default="0" />
			<description>
				Return info about the FakeIP and port(s) that we have been assigned, if any.
				[b]first_port[/b] is currently reserved and must be zero. Make sure and check result.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴result (int)
				┠╴identity_type (int)
				┠╴ip (int)
				┖╴ports (int)
				[/codeblock]
			</description>
		</method>
		<method name="getHTTPDownloadProgressPct">
			<return type="float" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Gets progress on downloading the body for the request. This will be zero unless a response header has already been received which included a content-length field. For responses that contain no content-length it will report zero for the duration of the request as the size is unknown until the connection closes.
			</description>
		</method>
		<method name="getHTTPRequestWasTimedOut">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Check if the reason the request failed was because we timed it out (rather than some harder failure). You'll want to call this within the context of [signal SteamServer.http_request_completed] callback if request_success is false.
			</description>
		</method>
		<method name="getHTTPResponseBodyData">
			<return type="PackedByteArray" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="buffer_size" type="int" />
			<description>
				Gets the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the http_request_completed call result associated with this request handle. You should first call [method SteamServer.getHTTPResponseBodySize] or use the body_size variable provided in the call result, you can then allocate a buffer with that size to pass into this function. This is only for HTTP requests which were sent with [method SteamServer.sendHTTPRequest]. Use [method SteamServer.getHTTPStreamingResponseBodyData] if you're using streaming HTTP requests via [method SteamServer.sendHTTPRequestAndStreamResponse].
			</description>
		</method>
		<method name="getHTTPResponseBodySize">
			<return type="int" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Gets the size of the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Stema.http_request_completed] or [signal SteamServer.http_request_data_received] associated with this request handle. If this returns successfully, then you can allocate a buffer with the provided size to fill with the data obtained from [method SteamServer.getHTTPResponseBodyData] or [method SteamServer.getHTTPStreamingResponseBodyData].
			</description>
		</method>
		<method name="getHTTPResponseHeaderSize">
			<return type="int" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="header_name" type="String" />
			<description>
				Checks if a header is present in an HTTP response and returns its size. This must be called after the HTTP request has completed and returned the HTTP response via the [signal SteamServer.http_request_completed] call result associated with this request handle. If the response header exists in the response, then you can allocate a correctly sized buffer to get the associated value with [method SteamServer.getHTTPResponseHeaderValue]. Here is a list of standard response header names on Wikipedia.
			</description>
		</method>
		<method name="getHTTPResponseHeaderValue">
			<return type="PackedByteArray" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="header_name" type="String" />
			<param index="2" name="buffer_size" type="int" />
			<description>
				Gets a header value from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal SteamServer.http_request_completed] call result associated with this request handle. You should first call [method SteamServer.getHTTPResponseHeaderSize] to check for the presence of the header and to get the size. You can then allocate a buffer with that size and pass it into this function. Here is a list of standard response header names on Wikipedia.
			</description>
		</method>
		<method name="getHTTPStreamingResponseBodyData">
			<return type="PackedByteArray" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="offset" type="int" />
			<param index="2" name="buffer_size" type="int" />
			<description>
				Gets the body data from a streaming HTTP response. This must be called after data is received from a streaming HTTP request via the [signal SteamServer.http_request_completed] callback associated with this request handle. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via [signal SteamServer.http_request_headers_received]. You can then append data to that buffer as it comes in. This is only for streaming HTTP requests which were sent with [method SteamServer.sendHTTPRequestAndStreamResponse]. Use [method SteamServer.getHTTPResponseBodyData] if you're using [method SteamServer.sendHTTPRequest].
			</description>
		</method>
		<method name="getHostedDedicatedServerPOPId">
			<return type="int" />
			<description>
				Returns 0 if SDR_LISTEN_PORT is not set. Otherwise, returns the data center the server is running in. This will be k_SteamDatagramPOPID_dev in non-production envirionment.
			</description>
		</method>
		<method name="getHostedDedicatedServerPort">
			<return type="int" />
			<description>
				Returns the value of the SDR_LISTEN_PORT environment variable. This is the UDP server your server will be listening on. This will configured automatically for you in production environments.
			</description>
		</method>
		<method name="getItemDefinitionProperty">
			<return type="String" />
			<param index="0" name="definition" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Gets a string property from the specified item definition. Gets a property value for a specific item definition.
				Note that some properties (for example, "name") may be localized and will depend on the current Steam language settings; see [method SteamServer.getCurrentGameLanguage]. Property names are always ASCII alphanumeric and underscores.
				Pass in NULL for name to get a comma-separated list of available property names.
				[b]Note:[/b] Call [method SteamServer.loadItemDefinitions] first, to ensure that items are ready to be used before calling [method SteamServer.getItemDefinitionProperty].
			</description>
		</method>
		<method name="getItemDownloadInfo">
			<return type="Dictionary" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Get info about a pending download of a workshop item that has 8 set.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴ret (bool)
				┠╴downloaded (int)
				┖╴total (int)
				[/codeblock]
			</description>
		</method>
		<method name="getItemInstallInfo">
			<return type="Dictionary" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Gets info about currently installed content on the disc for workshop items that have k_EItemStateInstalled (4) set.
				Calling this sets the "used" flag on the workshop item for the current player and adds it to their k_EUserUGCList_UsedOrPlayed (7) list.
				If k_EItemStateLegacyItem (2) is set then folder contains the path to the legacy file itself, not a folder.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴ret (bool)
				┠╴size (int)
				┠╴folder (string)
				┠╴folder_size (int)
				┖╴timestamp (int)
				[/codeblock]
			</description>
		</method>
		<method name="getItemPrice">
			<return type="Dictionary" />
			<param index="0" name="definition" type="int" />
			<description>
				After a successful call to [method SteamServer.requestPrices], you can call this method to get the pricing for a specific item definition.
			</description>
		</method>
		<method name="getItemState">
			<return type="int" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Gets the current state of a workshop item on this client.
				It should be one of the following:
				[codeblock]
				• 0 / None
				• 1 / Subscribed
				• 2 / Legacy
				• 4 / Installed
				• 8 / Update
				• 16 / Downloading
				• 32 / Pending
				[/codeblock]
			</description>
		</method>
		<method name="getItemUpdateProgress">
			<return type="Dictionary" />
			<param index="0" name="update_handle" type="int" />
			<description>
				Gets the progress of an item update.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴status (int)
				┠╴processed (int)
				┖╴total (int)
				[/codeblock]
			</description>
		</method>
		<method name="getItemsByID">
			<return type="int" />
			<param index="0" name="id_array" type="PackedInt64Array" />
			<description>
				Gets the state of a subset of the current user's inventory.
				The subset is specified by an array of item instance IDs.
				The results from this call can be serialized using [method SteamServer.serializeResult] and passed to other players to "prove" that the current user owns specific items, without exposing the user's entire inventory. For example, you could call this with the IDs of the user's currently equipped items and serialize this to a buffer, and then transmit this buffer to other players upon joining a game.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="getItemsWithPrices">
			<return type="Array" />
			<param index="0" name="length" type="int" />
			<description>
				After a successful call to [method SteamServer.requestPrices], you can call this method to get all the pricing for applicable item definitions. Use the result of [method SteamServer.getNumItemsWithPrices] as the the size of the arrays that you pass in.
			</description>
		</method>
		<method name="getListenSocketAddress">
			<return type="String" />
			<param index="0" name="socket" type="int" />
			<param index="1" name="with_port" type="bool" default="true" />
			<description>
				Returns local IP and port that a listen socket created using [method SteamServer.createListenSocketIP] is bound to.
				[b]Note:[/b] This is not how you find out your public IP that clients can connect to.
			</description>
		</method>
		<method name="getLocalPingLocation">
			<return type="Dictionary" />
			<description>
				Return location info for the current host. Returns the approximate age of the data, in seconds, or -1 if no data is available. You can use this value in [method SteamServer.checkPingDataUpToDate].
				It takes a few seconds to initialize access to the relay network. If you call this very soon after calling [method SteamServer.initializeRelayNetworkAccess], the data may not be available yet.
				This always return the most up-to-date information we have available right now, even if we are in the middle of re-calculating ping times.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴location (PackedByteArray)
				┖╴age (float)
				[/codeblock]
			</description>
		</method>
		<method name="getLocalTimestamp">
			<return type="int" />
			<description>
				A general purpose high resolution local timer with the following properties:
				Monotonicity is guaranteed.
				The initial value will be at least 24360030*1e6, i.e. about 30 days worth of microseconds. In this way, the timestamp value of 0 will always be at least "30 days ago". Also, negative numbers will never be returned.
				Wraparound / overflow is not a practical concern.
				If you are running under the debugger and stop the process, the clock might not advance the full wall clock time that has elapsed between calls. If the process is not blocked from normal operation, the timestamp values will track wall clock time, even if you don't call the function frequently.
				The value is only meaningful for this run of the process. Don't compare it to values obtained on another computer, or other runs of the same process.
			</description>
		</method>
		<method name="getNextOutgoingPacket">
			<return type="Dictionary" />
			<description>
				Gets a packet that the master server updater needs to send out on UDP when in GameSocketShare mode.
				[b]Note:[/b] This should only ever be called AFTER calling [method SteamServer.handleIncomingPacket] for any packets that came in that frame!
				[b]Note:[/b] This MUST be called repeatedly each frame until it returns 0 when in GameSocketShare mode.
				GameSocketShare mode can be enabled when calling [method SteamServer.serverInit].
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴length (int)
				┠╴out (PackedByteArray)
				┠╴address (uint32)
				┖╴port (uint16)
				[/codeblock]
			</description>
		</method>
		<method name="getNumSubscribedItems">
			<return type="int" />
			<description>
				Gets the total number of items the current user is subscribed to for the game or application.
			</description>
		</method>
				<method name="getNumSupportedGameVersions">
			<return type="int" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Get the number of supported game versions for this UGC content.
			</description>
		</method>
		<method name="getP2PSessionState">
			<return type="Dictionary" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Fills out a dictionary with details about the connection like whether or not there is an active connection; number of bytes queued on the connection; the last error code, if any; whether or not a relay server is being used; and the IP and Port of the remote user, if known.
				This should only needed for debugging purposes.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴connection_active (bool)
				┠╴connecting (bool)
				┠╴session_error (int)
				┠╴using_relay (bool)
				┠╴bytes_queued_for_send (int)
				┠╴packets_queued_for_send (int)
				┠╴remote_ip (int)
				┖╴remote_port (int)
				[/codeblock]
			</description>
		</method>
		<method name="getPOPCount">
			<return type="int" />
			<description>
				Get number of network points of presence in the config.
			</description>
		</method>
		<method name="getPOPList">
			<return type="Array" />
			<description>
				Get list of all POP IDs. Returns the number of entries that were filled into your list.
			</description>
		</method>
		<method name="getPSNID">
			<return type="int" />
			<param index="0" name="reference_name" type="String" />
			<description>
				Retrieve this identity's Playstation Network ID.
			</description>
		</method>
		<method name="getPingToDataCenter">
			<return type="Dictionary" />
			<param index="0" name="pop_id" type="int" />
			<description>
				Fetch ping time of best available relayed route from this host to the specified data center.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴pop_relay (int)
				┖╴ping (int)
				[/codeblock]
			</description>
		</method>
		<method name="getPublicIP">
			<return type="Dictionary" />
			<description>
				Gets the public IP of the server according to SteamServer.
				This is useful when the server is behind NAT and you want to advertise its IP in a lobby for other clients to directly connect to.
			</description>
		</method>
		<method name="getQueryUGCAdditionalPreview">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="preview_index" type="int" />
			<description>
				Retrieve the details of an additional preview associated with an individual workshop item after receiving a querying UGC call result.
				You should call this in a loop to get the details of all the workshop items returned.
				Before calling this you should call [method SteamServer.getQueryUGCNumAdditionalPreviews] to get number of additional previews.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴success (bool)
				┠╴handle (int)
				┠╴index (int)
				┠╴preview (int)
				┠╴url_or_video (string)
				┠╴filename (string)
				┖╴type (int)
				[/codeblock]
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCChildren">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="child_count" type="int" />
			<description>
				Retrieve the IDs of any child items of an individual workshop item after receiving a querying UGC call result. These items can either be a part of a collection or some other dependency (see [method SteamServer.addDependency]).
				You should create published_file_id with num_children provided in returned dictionary after getting the UGC details with [method SteamServer.getQueryUGCResult].
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴success (bool)
				┠╴handle (int)
				┠╴index (int)
				┖╴children (int)
				[/codeblock]
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCContentDescriptors">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="max_entries" type="int" />
			<description>
				Get an UGC item's content descriptors for mature content.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴result (int)
				┠╴handle (int)
				┠╴index (int)
				┖╴descriptors (array)
				[/codeblock]
				Descriptors array will contain a list of integers that correspond to the following UGC enums for descriptors:
				[codeblock]
				• 1 / Nudity or sexual content
				• 2 / Frequent violence or gore
				• 3 / Adult only sexual content
				• 4 / Gratuitous sexual content
				• 5 / Any mature content
				[/codeblock]
				[b]Note:[/b] Valve does not have any documentation covering this function at this time.
			</description>
		</method>
		<method name="getQueryUGCKeyValueTag">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="key_value_tag_index" type="int" />
			<description>
				Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
				You can then call [method SteamServer.getQueryUGCKeyValueTag] to get the details of each tag.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCMetadata">
			<return type="String" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Retrieve the developer set metadata of an individual workshop item after receiving a querying UGC call result.
				You should call this in a loop to get the details of all the workshop items returned.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [method SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCNumAdditionalPreviews">
			<return type="int" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Retrieve the number of additional previews of an individual workshop item after receiving a querying UGC call result.
				You can then call [method SteamServer.getQueryUGCAdditionalPreview] to get the details of each additional preview.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCNumKeyValueTags">
			<return type="int" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
				You can then call [getQueryUGCKeyValueTag](/functions/ugc/#getqueryugckeyvaluetag) to get the details of each tag.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCNumTags">
			<return type="int" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Available in SDK v1.51.
			Retrieve the number of tags for an individual workshop item after receiving a querying UGC call result.
			You can then call [method SteamServer.getQueryUGCTag] to get the tag name or [method SteamServer.getQueryUGCTagDisplayName] to get the localized tag string (if any).
			[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCPreviewURL">
			<return type="String" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Retrieve the URL to the preview image of an individual workshop item after receiving a querying UGC call result.
				You can use this URL to download and display the preview image instead of having to download it using the handle_preview_file key in the return dictionary from [method SteamServer.getQueryUGCResult].
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCResult">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Retrieve the details of an individual workshop item after receiving a querying UGC call result.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴result (int)
				┠╴file_id (int)
				┠╴file_type (int)
				┠╴creator_app_id (int)
				┠╴consumer_app_id (int)
				┠╴title (string)
				┠╴description (string)
				┠╴steam_id_owner (int)
				┠╴time_created (int)
				┠╴time_updated (int)
				┠╴time_added_to_user_list (int)
				┠╴visibility (int)
				┠╴banned (bool)
				┠╴accepted_for_use (bool)
				┠╴tags_truncated (bool)
				┠╴tags (string)
				┠╴handle_file (int)
				┠╴handle_preview-file (int)
				┠╴file_name (string)
				┠╴file_size (int)
				┠╴preview_file_size (int)
				┠╴url (string)
				┠╴votes_up (int)
				┠╴votes_down (int)
				┠╴score (float)
				┖╴num_children (int)
				[/codeblock]
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCStatistic">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="stat_type" type="int" enum="ItemStatistic" />
			<description>
				Retrieve various statistics of an individual workshop item after receiving a querying UGC call result.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴success (bool)
				┠╴handle (int)
				┠╴index (int)
				┠╴type (int)
				┖╴value (int)
				[/codeblock]
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCTag">
			<return type="String" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="tag_index" type="int" />
			<description>
				Available in SDK v1.51.
				Retrieve the "nth" tag associated with an individual workshop item after receiving a querying UGC call result.
				Before calling this you should call [method SteamServer.getQueryUGCNumTags] to get number of tags.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getQueryUGCTagDisplayName">
			<return type="String" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="tag_index" type="int" />
			<description>
				Available in SDK v1.51.
				Retrieve the "nth" display string (usually localized) for a tag, which is associated with an individual workshop item after receiving a querying UGC call result.
				Before calling this you should call [method SteamServer.getQueryUGCNumTags] to get number of tags.
				[b]Note:[/b] This must only be called with the handle obtained from a successful [signal SteamServer.ugc_query_completed] call result.
			</description>
		</method>
		<method name="getRelayNetworkStatus">
			<return type="int" enum="NetworkingAvailability" />
			<description>
				Fetch current status of the relay network.
				[signal SteamServer.relay_network_status] is also a callback. It will be triggered on both the user and gameserver interfaces any time the status changes, or ping measurement starts or stops.
				Possible returned statuses can be:
				[codeblock]
				• -102 / cannot try
				• -101 / failed
				• -100 / previously worked, now there is a problem
				• -10 / retrying
				• 0 / unknown
				• 1 / never tried
				• 2 / waiting
				• 3 / attempting
				• 100 / current
				[/codeblock]
			</description>
		</method>
		<method name="getRemoteFakeIPForConnection">
			<return type="Dictionary" />
			<param index="0" name="connection" type="int" />
			<description>
				If the connection was initiated using the "FakeIP" system, then we we can get an IP address for the remote host. If the remote host had a global FakeIP at the time the connection was established, this function will return that global IP.
				Otherwise, a FakeIP that is unique locally will be allocated from the local FakeIP address space, and that will be returned.
				This should also add the returning struct to your ip_addresses vector as fake_ip_address.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴result (int)
				┠╴port (int)
				┖╴ip_type (int)
				[/codeblock]
			</description>
		</method>
		<method name="getResultItemProperty">
			<return type="String" />
			<param index="0" name="index" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="this_inventory_handle" type="int" default="0" />
			<description>
				Gets the dynamic properties from an item in an inventory result set.
				Property names are always composed of ASCII letters, numbers, and/or underscores.
				If the results do not fit in the given buffer, partial results may be copied.
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="getResultItems">
			<return type="Array" />
			<param index="0" name="this_inventory_handle" type="int" default="0" />
			<description>
				Get the items associated with an inventory result handle.
				The returned array contains a list of item IDs (int).
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="getResultStatus">
			<return type="int" enum="Result" />
			<param index="0" name="this_inventory_handle" type="int" default="0" />
			<description>
				Find out the status of an asynchronous inventory result handle. This is a polling equivalent to registering a callback function for [signal SteamServer.inventory_result_ready].
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="getResultTimestamp">
			<return type="int" />
			<param index="0" name="this_inventory_handle" type="int" default="0" />
			<description>
				Gets the server time at which the result was generated.
				You can compare this value against getServerRealTime to determine the age of the result.
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
			</description>
		</method>
		<method name="getServerSteamID">
			<return type="int" />
			<description>
				Gets the Steam ID of the game server.
			</description>
		</method>
		<method name="getSessionConnectionInfo">
			<return type="Dictionary" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="get_connection" type="bool" />
			<param index="2" name="get_status" type="bool" />
			<description>
				Returns information about the latest state of a connection, if any, with the given peer. Primarily intended for debugging purposes, but can also be used to get more detailed failure information.
				Returns the value of connection state or 0 if no connection exists with specified peer. You may pass false for either get_connection or get_status if you do not need the corresponding details. Note that sessions time out after a while, so if a connection fails, or [method SteamServer.sendMessageToUser] returns 3, you cannot wait indefinitely to obtain the reason for failure.
			</description>
		</method>
		<method name="getSteamID">
			<return type="int" />
			<description>
				Gets the Steam ID of the game server.
			</description>
		</method>
		<method name="getSteamID32">
			<return type="int" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Get the Steam ID32 from a Steam ID64.
			</description>
		</method>
		<method name="getSubscribedItems">
			<return type="Array" />
			<description>
				Gets a list of all of the items the current user is subscribed to for the current game.
			</description>
		</method>
		<method name="getSupportedGameVersionData">
			<return type="Dictionary" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="version_index" type="int" />
			<description>
				Some items can specify that they have a version that is valid for a range of game versions (Steam branch).
				[codeblock]
				┠╴min (string)
				┠╴max (string)
				┖╴size (uint32)
				[/codeblock]
			</description>
		</method>
		<method name="getUserAchievement">
			<return type="Dictionary" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Gets the unlock status of the Achievement.
				The equivalent function for the local user is [method SteamServer.getAchievement].
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴steam_id (int)
				┠╴retrieved (bool)
				┠╴name (string)
				┖╴achieved (bool)
				[/codeblock]
			</description>
		</method>
		<method name="getUserContentDescriptorPreferences">
			<return type="Array" />
			<param index="0" name="max_entries" type="int" />
			<description>
				Return the user's community content descriptor preferences.
			</description>
		</method>
		<method name="getUserItemVote">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Gets the users vote status on a workshop item.
				Triggers a [signal SteamServer.get_item_vote_result]( callback.
			</description>
		</method>
		<method name="getUserStatFloat">
			<return type="float" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Gets the current value of the a stat for the specified user.
				You must have called [method SteamServer.requestUserStats] and it needs to return successfully via its callback prior to calling this.
				The equivalent function for the local user is [method SteamServer.getStat].
			</description>
		</method>
		<method name="getUserStatInt">
			<return type="int" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Gets the current value of the a stat for the specified user.
				You must have called [method SteamServer.requestUserStats] and it needs to return successfully via its callback prior to calling this.
				The equivalent function for the local user is [method SteamServer.getStat].
			</description>
		</method>
		<method name="getWorkshopEULAStatus">
			<return type="void" />
			<description>
				Asynchronously retrieves data about whether the user accepted the Workshop EULA for the current app.
			</description>
		</method>
		<method name="get_godotsteam_version" qualifiers="const">
			<return type="String" />
			<description>
				Returns the current version of GodotSteam you are using.
			</description>
		</method>
		<method name="grantPromoItems">
			<return type="int" />
			<description>
				Grant all potential one-time promotional items to the current user.
				This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant specific promotional items rather than all of them see: [method SteamServer.addPromoItem] and [method SteamServer.addPromoItems].
				Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result when you are done with it.
			</description>
		</method>
		<method name="handleIncomingPacket">
			<return type="Dictionary" />
			<param index="0" name="packet" type="int" />
			<param index="1" name="ip" type="String" />
			<param index="2" name="port" type="int" />
			<description>
				Handles a Steam master server packet when in GameSocketShare mode.
				When in GameSocketShare mode, instead of GameServer creating its own socket to talk to the master server on, it lets the game use its socket to forward messages back and forth. This prevents us from requiring server ops to open up yet another port in their firewalls.
				This should be called whenever a packet that starts with 0xFFFFFFFF comes in. That means it's for us.
				The IP and port parameters are used when you've elected to multiplex the game server's UDP socket rather than having the master server updater use its own sockets.
				Source engine games use this to simplify the job of the server admins, so they don't have to open up more ports on their firewalls.
				Only AFTER calling this, you should call [method SteamServer.getNextOutgoingPacket].
				GameSocketShare mode can be enabled when calling [method SteamServer.serverInit].
				The returned dictionary contains the following keys:
				[codeblock]
				┖╴data (PackedByteArray)
				[/codeblock]
			</description>
		</method>
		<method name="initAuthentication">
			<return type="int" enum="NetworkingAvailability" />
			<description>
				Indicate our desire to be ready participate in authenticated communications. If we are currently not ready, then steps will be taken to obtain the necessary certificates. (This includes a certificate for us, as well as any CA certificates needed to authenticate peers.)
			</description>
		</method>
		<method name="initRelayNetworkAccess">
			<return type="void" />
			<description>
				If you know that you are going to be using the relay network (for example, because you anticipate making P2P connections), call this to initialize the relay network. If you do not call this, the initialization will be delayed until the first time you use a feature that requires access to the relay network, which will delay that first access.
				You can also call this to force a retry if the previous attempt has failed. Performing any action that requires access to the relay network will also trigger a retry, and so calling this function is never strictly necessary, but it can be useful to call it a program launch time, if access to the relay network is anticipated. Use [method SteamServer.getRelayNetworkStatus] or listen for [signal SteamServer.relay_network_status] callbacks to know when initialization has completed. Typically initialization completes in a few seconds.
				[b]Note:[/b] dedicated servers hosted in known data centers do not need to call this, since they do not make routing decisions. However, if the dedicated server will be using P2P functionality, it will act as a "client" and this should be called.
			</description>
		</method>
		<method name="initWorkshopForGameServer">
			<return type="bool" />
			<param index="0" name="workshop_depot_id" type="int" />
			<param index="1" name="folder" type="String" />
			<description>
				Lets game servers set a specific workshop folder before issuing any UGC commands.
				This is helpful if you want to support multiple game servers running out of the same install folder.
			</description>
		</method>
		<method name="isAnonAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this an anonymous account?
			</description>
		</method>
		<method name="isAnonUserAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this an anonymous user account?
			</description>
		</method>
		<method name="isChatAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this a chat account?
			</description>
		</method>
		<method name="isClanAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this a clan account?
			</description>
		</method>
		<method name="isConsoleUserAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this a console user account?
			</description>
		</method>
		<method name="isIndividualAccount">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this an individual account?
			</description>
		</method>
		<method name="isLobby">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Is this a lobby?
			</description>
		</method>
		<method name="isServerSecure">
			<return type="bool" />
			<description>
				Valve has no notes about this but we assume it just returns true/false if the server is considered secure.
			</description>
		</method>
		<method name="loadItemDefinitions">
			<return type="bool" />
			<description>
				Triggers an asynchronous load and refresh of item definitions.
				Item definitions are a mapping of "definition IDs" (integers between 1 and 999999999) to a set of string properties. Some of these properties are required to display items on the Steam community web site. Other properties can be defined by applications. There is no reason to call this function if your game hardcoded the numeric definition IDs (e.g. purple face mask = 20, blue weapon mod = 55) and does not allow for adding new item types without a client patch.
				Triggers a [signal SteamServer.inventory_definition_update] callback.
			</description>
		</method>
		<method name="logOff">
			<return type="void" />
			<description>
				Begin process of logging the game server out of SteamServer.
			</description>
		</method>
		<method name="logOn">
			<return type="void" />
			<param index="0" name="token" type="String" />
			<description>
				Begin process to login to a persistent game server account.
			</description>
		</method>
		<method name="logOnAnonymous">
			<return type="void" />
			<description>
				Login to a generic, anonymous account.
			</description>
		</method>
		<method name="loggedOn">
			<return type="bool" />
			<description>
				Checks if the current user's Steam client is connected to the Steam servers.
				If it's not then no real-time services provided by the Steamworks API will be enabled. The Steam client will automatically be trying to recreate the connection as often as possible. When the connection is restored a [signal SteamServer.steam_server_connected] callback will be posted.
				You usually don't need to check for this yourself. All of the API calls that rely on this will check internally. Forcefully disabling stuff when the player loses access is usually not a very good experience for the player and you could be preventing them from accessing APIs that do not need a live connection to SteamServer.
			</description>
		</method>
		<method name="parsePingLocationString">
			<return type="Dictionary" />
			<param index="0" name="string" type="String" />
			<description>
				Parse back location_string string. Returns false if we couldn't understand the string.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴success (bool)
				┖╴ping_location (PoolByeArray)
				[/codeblock]
			</description>
		</method>
		<method name="prioritizeHTTPRequest">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Prioritizes a request which has already been sent by moving it at the front of the queue.
			</description>
		</method>
		<method name="readP2PPacket">
			<return type="Dictionary" />
			<param index="0" name="packet" type="int" />
			<param index="1" name="channel" type="int" default="0" />
			<description>
				Reads in a packet that has been sent from another user via [method SteamServer.sendP2PPacket].
				This call is not blocking, and will return false if no data is available.
				Before calling this you should have called [method SteamServer.getAvailableP2PPacketSize] / [method SteamServer.isP2PPacketAvailable].
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴data (PackedByteArray)
				┖╴remote_steam_id (int)
				[/codeblock]
			</description>
		</method>
		<method name="receiveMessagesOnChannel">
			<return type="Array" />
			<param index="0" name="channel" type="int" />
			<param index="1" name="max_messages" type="int" />
			<description>
				Reads the next message that has been sent from another user via [method SteamServer.sendMessageToUser] on the given channel. Returns number of messages returned into your list. (0 if no message are available on that channel.)
				The returned array contains a list of:
				[codeblock]
				┖╴messages (dictionary)
				    ┠╴payload (string)
				    ┠╴size (int)
				    ┠╴connection (int)
				    ┠╴identity (string)
				    ┠╴receiver_user_data (int) - Not used when sending messages
				    ┠╴time_received (int)
				    ┠╴message_number (int)
				    ┠╴channel (int)
				    ┠╴flags (int)
				    ┖╴sender_user_data (int) - Not used when receving messages
				[/codeblock]
			</description>
		</method>
		<method name="receiveMessagesOnConnection">
			<return type="Array" />
			<param index="0" name="connection" type="int" />
			<param index="1" name="max_messages" type="int" />
			<description>
				Fetch the next available message(s) from the connection, if any. Returns the number of messages returned into your array, up to max_messages. If the connection handle is invalid, -1 is returned. If no data is available, 0, is returned.
				The returned array contains a list of:
				[codeblock]
				┖╴messages (dictionary):
				    ┠╴payload (string)
				    ┠╴size (int)
				    ┠╴connection (int)
				    ┠╴identity (string)
				    ┠╴receiver_user_data (int) - Not used when sending messages
				    ┠╴time_received (int)
				    ┠╴message_number (int)
				    ┠╴channel (int)
				    ┠╴flags (int)
				    ┖╴sender_user_data (int) - Not used when receving messages
				[/codeblock]
			</description>
		</method>
		<method name="receiveMessagesOnPollGroup">
			<return type="Array" />
			<param index="0" name="poll_group" type="int" />
			<param index="1" name="max_messages" type="int" />
			<description>
				Same as [method SteamServer.receiveMessagesOnConnection], but will return the next messages available on any connection in the poll group. Examine connection to know which connection. user_data might also be useful.
			</description>
		</method>
		<method name="releaseCookieContainer">
			<return type="bool" />
			<param index="0" name="cookie_handle" type="int" />
			<description>
				Releases a cookie container, freeing the memory allocated within SteamServer. You must call this when you are done using each HTTP cookie container handle that you obtained via [method SteamServer.createCookieContainer]!
			</description>
		</method>
		<method name="releaseHTTPRequest">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Releases an HTTP request handle, freeing the memory allocated within SteamServer. You must call this when you are done using each HTTP request handle that you obtained via [method SteamServer.createHTTPRequest]!
			</description>
		</method>
		<method name="releaseQueryUGCRequest">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<description>
				Releases a UGC query handle when you are done with it to free up memory.
			</description>
		</method>
		<method name="removeAppDependency">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="app_id" type="int" />
			<description>
				Removes the dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method SteamServer.getAppDependencies].
				Triggers a [signal SteamServer.remove_app_dependency_result] callback.
			</description>
		</method>
		<method name="removeContentDescriptor">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="descriptor_id" type="int" />
			<description>
				Removes a mature content descriptor from a piece of UGC.
				[b]Note:[/b] Valve has no documentation on this function currently.
			</description>
		</method>
		<method name="removeDependency">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="child_published_file_id" type="int" />
			<description>
				Removes a workshop item as a dependency from the specified item.
				Triggers a [signal SteamServer.remove_ugc_dependency_result] callback.
			</description>
		</method>
		<method name="removeItemFromFavorites">
			<return type="void" />
			<param index="0" name="app_id" type="int" />
			<param index="1" name="published_file_id" type="int" />
			<description>
				Removes a workshop item from the users favorites list.
				Triggers a [signal SteamServer.user_favorite_items_list_changed]callback.
			</description>
		</method>
		<method name="removeItemKeyValueTags">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="key" type="String" />
			<description>
				Removes an existing key value tag from an item.
				You can only call this up to 100 times per item update. If you need remove more tags than that you'll need to make subsequent item updates.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="removeItemPreview">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="index" type="int" />
			<description>
				Removes an existing preview from an item.
			</description>
		</method>
		<method name="removeProperty">
			<return type="bool" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Removes a dynamic property for the given item.
				[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
			</description>
		</method>
		<method name="requestEligiblePromoItemDefinitionsIDs">
			<return type="void" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Request the list of "eligible" promo items that can be manually granted to the given user.
				These are promo items of type "manual" that won't be granted automatically. An example usage of this is an item that becomes available every week. After calling this function you need to call [method SteamServer.getEligiblePromoItemDefinitionIDs] to get the actual item definition ids.
				Triggers a [signal SteamServer.inventory_eligible_promo_item] callback.
			</description>
		</method>
		<method name="requestPrices">
			<return type="void" />
			<description>
				Request prices for all item definitions that can be purchased in the user's local currency. A [signal SteamServer.inventory_request_prices_result] call result will be returned with the user's local currency code. After that, you can call [method SteamServer.getNumItemsWithPrices] and [method SteamServer.getItemsWithPrices] to get prices for all the known item definitions, or [method SteamServer.getItemPrice] for a specific item definition.
				Triggers a [signal SteamServer.inventory_request_prices_result] callback.
			</description>
		</method>
		<method name="requestUserGroupStatus">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="group_id" type="int" />
			<description>
				Checks if a user is in the specified Steam group.
			</description>
		</method>
		<method name="requestUserStats">
			<return type="void" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Asynchronously downloads stats and achievements for the specified user from the server.
				These stats are not automatically updated; you'll need to call this function again to refresh any data that may have change.
				To keep from using too much memory, an least recently used cache (LRU) is maintained and other user's stats will occasionally be unloaded. When this happens a [signal SteamServer.user_stats_unloaded] callback is sent. After receiving this callback the user's stats will be unavailable until this function is called again.
				The equivalent function for the local user is [method SteamServer.requestCurrentStats].
				Triggers a [signal SteamServer.user_stats_received] callback.
			</description>
		</method>
		<method name="resetIdentity">
			<return type="void" />
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Reset the identity associated with this instance. Any open connections are closed. Any previous certificates, etc are discarded. You can pass a specific identity that you want to use, or you can pass NULL, in which case the identity will be invalid until you set it using [nethod SteamServer.setCertificate].
				[b]Note:[/b] This function is not actually supported on Steam! It is included for use on other platforms where the active user can sign out and a new user can sign in.
			</description>
		</method>
		<method name="runNetworkingCallbacks">
			<return type="void" />
			<description>
				Invoke all callback functions queued for this interface. See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc. You don't need to call this if you are using Steam's callback dispatch mechanism: [method SteamServer.run_callbacks].
			</description>
		</method>
		<method name="run_callbacks">
			<return type="void" />
			<description>
				Process callbacks / call results from SteamServer.
			</description>
		</method>
		<method name="secure">
			<return type="bool" />
			<description>
				Checks whether the game server is in "Secure" mode.
			</description>
		</method>
		<method name="sendHTTPRequest">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Sends an HTTP request. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. If you have multiple requests in flight at the same time you can use [method SteamServer.prioritizeHTTPRequest] or [method SteamServer.deferHTTPRequest] to set the priority of the request.
				If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
				If the data you are expecting is large, you can use [method SteamServer.sendHTTPRequestAndStreamResponse] to stream the data in chunks.
			</description>
		</method>
		<method name="sendHTTPRequestAndStreamResponse">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<description>
				Sends an HTTP request and streams the response back in chunks. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via http_request_headers_received. You can then append data to that buffer as it comes in.
				If you have multiple requests in flight at the same time you can use [method SteamServer.prioritizeHTTPRequest] or [method Stea.deferHTTPRequest] to set the priority of the request.
				If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
				If the data you are expecting is small (on the order of a few megabytes or less) then you'll likely want to use [method SteamServer.sendHTTPRequest].
			</description>
		</method>
		<method name="sendMessageToConnection">
			<return type="Dictionary" />
			<param index="0" name="connection_handle" type="int" />
			<param index="1" name="data" type="PackedByteArray" />
			<param index="2" name="flags" type="int" />
			<description>
				Send a message to the remote host on the specified connection.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴result (int)
				┖╴message_number (int)
				[/codeblock]
			</description>
		</method>
		<method name="sendMessageToUser">
			<return type="int" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="data" type="PackedByteArray" />
			<param index="2" name="flags" type="int" />
			<param index="3" name="channel" type="int" />
			<description>
				Sends a message to the specified host via identity_reference. If we don't already have a session with that user, a session is implicitly created. There might be some handshaking that needs to happen before we can actually begin sending message data. If this handshaking fails and we can't get through, an error will be posted via the callback [signal SteamServer.network_messages_session_failed]. There is no notification when the operation succeeds. (You should have the peer send a reply for this purpose.)
				Sending a message to a host will also implicitly accept any incoming connection from that host.
				[b]flags[/b] is a bitmask of k_nSteamNetworkingSend_xxx options.
				[b]channel[/b] is a routing number you can use to help route message to different systems. You'll have to call [method SteamServer.receiveMessagesOnChannel] with the same channel number in order to retrieve the data on the other end.
				Using different channels to talk to the same user will still use the same underlying connection, saving on resources. If you don't need this feature, use 0. Otherwise, small integers are the most efficient.
				It is guaranteed that reliable messages to the same host on the same channel will be be received by the remote host (if they are received at all) exactly once, and in the same order that they were sent.
				No other order guarantees exist! In particular, unreliable messages may be dropped, received out of order with respect to each other and with respect to reliable data, or may be received multiple times. Messages on different channels are not guaranteed to be received in the order they were sent.
				A note for those familiar with TCP/IP ports, or converting an existing codebase that opened multiple sockets: You might notice that there is only one channel, and with TCP/IP each endpoint has a port number. You can think of the channel number as the destination port. If you need each message to also include a source port (so the recipient can route the reply), then just put that in your message. That is essentially how UDP works!
			</description>
		</method>
		<method name="sendMessages">
			<return type="void" />
			<param index="0" name="messages" type="int" />
			<param index="1" name="data" type="PackedByteArray" />
			<param index="2" name="connection_handle" type="int" />
			<param index="3" name="flags" type="int" />
			<description>
				Send one or more messages without copying the message payload. This is the most efficient way to send messages.
			</description>
		</method>
		<method name="sendP2PPacket">
			<return type="bool" />
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="data" type="PackedByteArray" />
			<param index="2" name="send_type" type="int" enum="P2PSend" />
			<param index="3" name="channel" type="int" default="0" />
			<description>
				Sends a P2P packet to the specified user.
				This is a session-less API which automatically establishes NAT-traversing or Steam relay server connections.
				See EP2PSend for descriptions of the different ways of sending packets. The integers passed in GodotSteam are:
				[codeblock]
				• 0 / send ureliable
				• 1 / send unreliable, no delay
				• 2 / send reliable
				• 3 / send reliable with buffering
				[/codeblock]
				The type of data you send is arbitrary, you can use an off the shelf system like Protocol Buffers or Cap'n Proto to encode your packets in an efficient way, or you can create your own messaging system.
				Sends a P2P packet to the specified user.
				Triggers a [signal SteamServer.p2p_session_request] callback.
				True if the packet was successfully sent. Note that this does not mean successfully received, if we can't get through to the user after a timeout of 20 seconds, then an error will be posted via the [signal SteamServer.p2p_session_connect_fail] callback.
				[b]Note:[/b] The first packet send may be delayed as the NAT-traversal code runs.
			</description>
		</method>
		<method name="sendQueryUGCRequest">
			<return type="void" />
			<param index="0" name="update_handle" type="int" />
			<description>
				Send a UGC query to SteamServer.
				This must be called with a handle obtained from [method SteamServer.createQueryUserUGCRequest], [method SteamServer.createQueryAllUGCRequest], or [method SteamServer.createQueryUGCDetailsRequest] to actually send the request to SteamServer.
				Before calling this you should use one or more of the following APIs to customize your query: [method SteamServer.addRequiredTag], [method SteamServer.addExcludedTag], [method SteamServer.setReturnOnlyIDs], [method SteamServer.setReturnKeyValueTags], [method SteamServer.setReturnLongDescription], [method SteamServer.setReturnMetadata], [method SteamServer.setReturnChildren], [method SteamServer.setReturnAdditionalPreviews], [method SteamServer.setReturnTotalOnly], [method SteamServer.setLanguage], [method SteamServer.setAllowCachedResponse], [method SteamServer.setCloudFileNameFilter], [method SteamServer.setMatchAnyTag], [method SteamServer.setSearchText], [method SteamServer.setRankedByTrendDays], or [method SteamServer.addRequiredKeyValueTag].
				Triggers a [signal SteamServer.ugc_query_completed] callback.
			</description>
		</method>
		<method name="serializeResult">
			<return type="PackedByteArray" />
			<param index="0" name="this_inventory_handle" type="int" default="0" />
			<description>
				Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.
				A result set can be serialized on the local client, transmitted to other players via your game networking, and deserialized by the remote players. This is a secure way of preventing hackers from lying about posessing rare/high-value items. Serializes a result set with signature bytes to an output buffer. The size of a serialized result depends on the number items which are being serialized. When securely transmitting items to other players, it is recommended to use [method SteamServer.getItemsByID] first to create a minimal result set.
				[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
				Results have a built-in timestamp which will be considered "expired" after an hour has elapsed. See [method SteamServer.deserializeResult] for expiration handling.
			</description>
		</method>
		<method name="serverInit">
			<return type="bool" />
			<param index="0" name="ip" type="String" />
			<param index="1" name="game_port" type="int" />
			<param index="2" name="query_port" type="int" />
			<param index="3" name="server_mode" type="int" enum="ServerMode" />
			<param index="4" name="version_number" type="String" />
			<description>
				Initialize SteamGameServer client and interface objects, and set server properties which may not be changed.
				After calling this function, you should set any additional server parameters, and then [method SteamServer.logOnAnonymous] or [method SteamServer.logOn].
			</description>
		</method>
		<method name="serverInitEx">
			<return type="Dictionary" />
			<param index="0" name="ip" type="String" />
			<param index="1" name="game_port" type="int" />
			<param index="2" name="query_port" type="int" />
			<param index="3" name="server_mode" type="int" enum="ServerMode" />
			<param index="4" name="version_number" type="String" />
			<description>
				Initialize SteamGameServer client and interface objects, and set server properties which may not be changed.
				After calling this function, you should set any additional server parameters, and then [method SteamServer.logOnAnonymous] or [method SteamServer.logOn].
				On success STEAM_API_INIT_RESULT_OK is returned.  Otherwise, if error_message is non-NULL, it will receive a non-localized message that explains the reason for the failure.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴status (int)
				┖╴verbal (string)
				[/codeblock]
			</description>
		</method>
		<method name="serverReleaseCurrentThreadMemory">
			<return type="void" />
			<description>
				Frees all API-related memory associated with the calling thread. This memory is released automatically by RunCallbacks so single-threaded servers do not need to call this.
			</description>
		</method>
		<method name="serverShutdown">
			<return type="void" />
			<description>
				Shut down the server connection to SteamServer.
			</description>
		</method>
		<method name="setAdminQuery">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="admin_query" type="bool" />
			<description>
				Admin queries return hidden items.
			</description>
		</method>
		<method name="setAdvertiseServerActive">
			<return type="void" />
			<param index="0" name="active" type="bool" />
			<description>
				Indicate whether you wish to be listed on the master server list and/or respond to server browser / LAN discovery packets.
				The server starts with this value set to false.  You should set all relevant server parameters before enabling advertisement on the server.
			</description>
		</method>
		<method name="setAllowCachedResponse">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="max_age_seconds" type="int" />
			<description>
				Sets whether results will be returned from the cache for the specific period of time on a pending UGC Query.
			</description>
		</method>
		<method name="setBotPlayerCount">
			<return type="void" />
			<param index="0" name="bots" type="int" />
			<description>
				Sets the number of bot/AI players on the game server. The default value is 0.
			</description>
		</method>
		<method name="setCertificate">
			<return type="Dictionary" />
			<param index="0" name="certificate" type="PackedByteArray" />
			<description>
				Set the certificate. The certificate blob should be the output of SteamDatagram_CreateCert.
			</description>
		</method>
		<method name="setCloudFileNameFilter">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="match_cloud_filename" type="String" />
			<description>
				Sets to only return items that have a specific filename on a pending UGC Query.
				[b]Note:[/b] This can only be used with [method SteamServer.createQueryUserUGCRequest].
				[b]Note:[/b] This must be set before you send a UGC Query handle using [method SteamServer.sendQueryUGCRequest].
			</description>
		</method>
		<method name="setConnectionConfigValueFloat">
			<return type="bool" />
			<param index="0" name="connection" type="int" />
			<param index="1" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="2" name="value" type="float" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setConnectionConfigValueInt32">
			<return type="bool" />
			<param index="0" name="connection" type="int" />
			<param index="1" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="2" name="value" type="int" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setConnectionConfigValueString">
			<return type="bool" />
			<param index="0" name="connection" type="int" />
			<param index="1" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="2" name="value" type="String" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setConnectionDetails">
			<return type="int" />
			<param index="0" name="details" type="String" />
			<param index="1" name="connection_details" type="int" />
			<description>
				Set connection details for players once game is found so they can connect to this server.
			</description>
		</method>
		<method name="setConnectionName">
			<return type="void" />
			<param index="0" name="peer" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Set a name for the connection, used mostly for debugging.
			</description>
		</method>
		<method name="setConnectionPollGroup">
			<return type="bool" />
			<param index="0" name="connection_handle" type="int" />
			<param index="1" name="poll_group" type="int" />
			<description>
				Assign a connection to a poll group. Note that a connection may only belong to a single poll group. Adding a connection to a poll group implicitly removes it from any other poll group it is in.
			</description>
		</method>
		<method name="setDedicatedServer">
			<return type="void" />
			<param index="0" name="dedicated" type="bool" />
			<description>
				Sets the whether this is a dedicated server or a listen server. The default is listen server.
			</description>
		</method>
		<method name="setGameData">
			<return type="void" />
			<param index="0" name="data" type="String" />
			<description>
				Sets a string defining the "gamedata" for this server, this is optional, but if set it allows users to filter in the matchmaking/server-browser interfaces based on the value.
				This is usually formatted as a comma or semicolon separated list.
				Don't set this unless it actually changes, its only uploaded to the master once; when acknowledged.
			</description>
		</method>
		<method name="setGameDescription">
			<return type="void" />
			<param index="0" name="description" type="String" />
			<description>
				Sets the game description. Setting this to the full name of your game is recommended.
				b]Note:[/b] This is required for all game servers and can only be set before calling [method SteamServer.logOn] or [method SteamServer.logOnAnonymous].
			</description>
		</method>
		<method name="setGameTags">
			<return type="void" />
			<param index="0" name="tags" type="String" />
			<description>
				Sets a string defining the "gametags" for this server, this is optional, but if set it allows users to filter in the matchmaking/server-browser interfaces based on the value.
				This is usually formatted as a comma or semicolon separated list.
				Don't set this unless it actually changes, its only uploaded to the master once; when acknowledged.
			</description>
		</method>
		<method name="setGlobalConfigValueFloat">
			<return type="bool" />
			<param index="0" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="1" name="value" type="float" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setGlobalConfigValueInt32">
			<return type="bool" />
			<param index="0" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="1" name="value" type="int" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setGlobalConfigValueString">
			<return type="bool" />
			<param index="0" name="config" type="int" enum="NetworkingConfigValue" />
			<param index="1" name="value" type="String" />
			<description>
				Set a configuration value.
			</description>
		</method>
		<method name="setHTTPCookie">
			<return type="bool" />
			<param index="0" name="cookie_handle" type="int" />
			<param index="1" name="host" type="String" />
			<param index="2" name="url" type="String" />
			<param index="3" name="cookie" type="String" />
			<description>
				Adds a cookie to the specified cookie container that will be used with future requests.
			</description>
		</method>
		<method name="setHTTPRequestAbsoluteTimeoutMS">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="milliseconds" type="int" />
			<description>
				Set an absolute timeout in milliseconds for the HTTP request.
				This is the total time timeout which is different than the network activity timeout which is set with [method SteamServer.setHTTPRequestNetworkActivityTimeout] which can bump everytime we get more data.
			</description>
		</method>
		<method name="setHTTPRequestContextValue">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="context_value" type="int" />
			<description>
				Set a context value for the request, which will be returned in the [signal SteamServer.http_request_completed] callback after sending the request.
				This is just so the caller can easily keep track of which callbacks go with which request data.
				Must be called before sending the request.
			</description>
		</method>
		<method name="setHTTPRequestCookieContainer">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="cookie_handle" type="int" />
			<description>
				Associates a cookie container to use for an HTTP request.
			</description>
		</method>
		<method name="setHTTPRequestGetOrPostParameter">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="value" type="String" />
			<description>
				Set a GET or POST parameter value on the HTTP request.
				Must be called prior to sending the request.
			</description>
		</method>
		<method name="setHTTPRequestHeaderValue">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="header_name" type="String" />
			<param index="2" name="header_value" type="String" />
			<description>
				Set a request header value for the HTTP request.
				Must be called before sending the request.
				A full list of standard request fields are available here on Wikipedia. The User-Agent field is explicitly disallowed as it gets overwritten when the request is sent.
			</description>
		</method>
		<method name="setHTTPRequestNetworkActivityTimeout">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="timeout_seconds" type="int" />
			<description>
				Set the timeout in seconds for the HTTP request.
				The default timeout is 60 seconds if you don't call this. This can get bumped everytime we get more data. Use [method SteamServer.setHTTPRequestAbsoluteTimeoutMS] if you need a strict maximum timeout.
			</description>
		</method>
		<method name="setHTTPRequestRawPostBody">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="content_type" type="String" />
			<param index="2" name="body" type="String" />
			<description>
				Sets the body for an HTTP Post request.
				Will fail and return false on a GET request, and will fail if POST params have already been set for the request. Setting this raw body makes it the only contents for the post, the content_type parameter will set the "content-type" header for the request to inform the server how to interpret the body.
			</description>
		</method>
		<method name="setHTTPRequestRequiresVerifiedCertificate">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="require_verified_certificate" type="bool" />
			<description>
				Sets that the HTTPS request should require verified SSL certificate via machines certificate trust store.
				This currently only works Windows and macOS.
			</description>
		</method>
		<method name="setHTTPRequestUserAgentInfo">
			<return type="bool" />
			<param index="0" name="request_handle" type="int" />
			<param index="1" name="user_agent_info" type="String" />
			<description>
				Set additional user agent info for a request.
				This doesn't clobber the normal user agent, it just adds the extra info on the end. Sending NULL or an empty string resets the user agent info to the default value.
			</description>
		</method>
		<method name="setItemContent">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="content_folder" type="String" />
			<description>
				Sets the folder that will be stored as the content for an item.
				For efficient upload and download, files should not be merged or compressed into single files (e.g. zip files).
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemDescription">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="description" type="String" />
			<description>
				Sets a new description for an item.
				The description must be limited to the length defined by k_cchPublishedDocumentDescriptionMax (8000).
				You can set what language this is for by using [method SteamServer.setItemUpdateLanguage], if no language is set then "english" is assumed.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemMetadata">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="ugc_metadata" type="String" />
			<description>
				Sets arbitrary metadata for an item. This metadata can be returned from queries without having to download and install the actual content.
				The metadata must be limited to the size defined by k_cchDeveloperMetadataMax (5000).
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemPreview">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="preview_file" type="String" />
			<description>
				Sets the primary preview image for the item.
				The format should be one that both the web and the application (if necessary) can render. Suggested formats include JPG, PNG and GIF.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemTags">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="tag_array" type="Array" />
			<param index="2" name="allow_admin_tags" type="bool" default="false" />
			<description>
				Sets arbitrary developer specified tags on an item.
				Each tag must be limited to 255 characters. Tag names can only include printable characters, excluding ','.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemTitle">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="title" type="String" />
			<description>
				Sets a new title for an item.
				The title must be limited to the size defined by k_cchPublishedDocumentTitleMax (128).
				You can set what language this is for by using [method SteamServer.setItemUpdateLanguage], if no language is set then "english" is assumed.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemUpdateLanguage">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="language" type="String" />
			<description>
				Sets the language of the title and description that will be set in this item update.
				This must be in the format of the API language code.
				If this is not set then "english" is assumed.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setItemVisibility">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="visibility" type="int" enum="RemoteStoragePublishedFileVisibility" />
			<description>
				Sets the visibility of an item.
			</description>
		</method>
		<method name="setKeyValue">
			<return type="void" />
			<param index="0" name="key" type="String" />
			<param index="1" name="value" type="String" />
			<description>
				Call this to add/update a key/value pair.
			</description>
		</method>
		<method name="setLanguage">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="language" type="String" />
			<description>
				Sets the language to return the title and description in for the items on a pending UGC Query.
				This must be in the format of the API language code.
				If this is not set then "english" is assumed.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setMapName">
			<return type="void" />
			<param index="0" name="map" type="String" />
			<description>
				Sets the name of map to report in the server browser.
			</description>
		</method>
		<method name="setMatchAnyTag">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="match_any_tag" type="bool" />
			<description>
				Sets whether workshop items will be returned if they have one or more matching tag, or if all tags need to match on a pending UGC Query.
				[b]Note:[/b] This can only be used with [method SteamServer.createQueryAllUGCRequest].
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setMaxPlayerCount">
			<return type="void" />
			<param index="0" name="players_max" type="int" />
			<description>
				Sets the maximum number of players allowed on the server at once.
				This value may be changed at any time.
			</description>
		</method>
		<method name="setModDir">
			<return type="void" />
			<param index="0" name="mod_directory" type="String" />
			<description>
				Sets the game directory.
				This should be the same directory game where gets installed into. Just the folder name, not the whole path. e.g. "Spacewar".
				[b]Note:[/b] This is required for all game servers and can only be set before calling [method SteamServer.logOn] or [method SteamServer.logOnAnonymous].
			</description>
		</method>
		<method name="setPasswordProtected">
			<return type="void" />
			<param index="0" name="password_protected" type="bool" />
			<description>
				Set whether the game server will require a password once when the user tries to join.
			</description>
		</method>
		<method name="setProduct">
			<return type="void" />
			<param index="0" name="product" type="String" />
			<description>
				Sets the game product identifier. This is currently used by the master server for version checking purposes.
				Converting the games app ID to a string for this is recommended.
				[b]Note:[/b] This is required for all game servers and can only be set before calling [method SteamServer.logOn] or [method SteamServer.logOnAnonymous].
			</description>
		</method>
		<method name="setPropertyBool">
			<return type="bool" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="value" type="bool" />
			<param index="3" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Sets a dynamic property for the given item. Supported value types are boolean.
				[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
			</description>
		</method>
		<method name="setPropertyFloat">
			<return type="bool" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="value" type="float" />
			<param index="3" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Sets a dynamic property for the given item. Supported value types are 32 bit floats.
				[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. Also note this different from this_inventory_handle and is stored separately.
			</description>
		</method>
		<method name="setPropertyInt">
			<return type="bool" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="value" type="int" />
			<param index="3" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Sets a dynamic property for the given item. Supported value types are 64 bit integers.
				[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
			</description>
		</method>
		<method name="setPropertyString">
			<return type="bool" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="value" type="String" />
			<param index="3" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Sets a dynamic property for the given item. Supported value types are strings.
				[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
			</description>
		</method>
		<method name="setRankedByTrendDays">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="days" type="int" />
			<description>
				Sets whether the order of the results will be updated based on the rank of items over a number of days on a pending UGC Query.
				[b]Note:[/b] This can only be used with [method SteamServer.createQueryAllUGCRequest].
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setRegion">
			<return type="void" />
			<param index="0" name="region" type="String" />
			<description>
				Set the region the server is located in.
			</description>
		</method>
		<method name="setRequiredGameVersions">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="game_branch_min" type="String" />
			<param index="2" name="game_branch_max" type="String" />
			<description>
				An empty string for either parameter means that it will match any version on that end of the range. This will only be applied if the actual content has been changed.
			</description>
		</method>
		<method name="setReturnAdditionalPreviews">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_additional_previews" type="bool" />
			<description>
				Sets whether to return any additional images/videos attached to the items on a pending UGC Query.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnChildren">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_children" type="bool" />
			<description>
				Sets whether to return the IDs of the child items of the items on a pending UGC Query.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnKeyValueTags">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_key_value_tags" type="bool" />
			<description>
				Sets whether to return any key-value tags for the items on a pending UGC Query.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnLongDescription">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_long_description" type="bool" />
			<description>
				Sets whether to return the full description for the items on a pending UGC Query.
				If you don't set this then you only receive the summary which is the description truncated at 255 bytes.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnMetadata">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_metadata" type="bool" />
			<description>
				Sets whether to return the developer specified metadata for the items on a pending UGC Query.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnOnlyIDs">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_only_ids" type="bool" />
			<description>
				Sets whether to only return IDs instead of all the details on a pending UGC Query.
				This is useful for when you don't need all the information (e.g. you just want to get the IDs of the items a user has in their favorites list.)
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnPlaytimeStats">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="days" type="int" />
			<description>
				Sets whether to return the the playtime stats on a pending UGC Query.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setReturnTotalOnly">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="return_total_only" type="bool" />
			<description>
				Sets whether to only return the the total number of matching items on a pending UGC Query.
				The actual items will not be returned when [signal SteamServer.ugc_query_completed] is called.
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setSearchText">
			<return type="bool" />
			<param index="0" name="query_handle" type="int" />
			<param index="1" name="search_text" type="String" />
			<description>
				Sets a string to that items need to match in either the title or the description on a pending UGC Query.
				[b]Note:[/b] This can only be used with [method SteamServer.createQueryAllUGCRequest].
				[b]Note:[/b] This must be set before you submit the UGC query handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="setServerName">
			<return type="void" />
			<param index="0" name="name" type="String" />
			<description>
				Sets the name of server as it will appear in the server browser.
			</description>
		</method>
		<method name="setSpectatorPort">
			<return type="void" />
			<param index="0" name="port" type="int" />
			<description>
				Set whether the game server allows spectators, and what port they should connect on. The default value is 0, meaning the service is not used.
			</description>
		</method>
		<method name="setSpectatorServerName">
			<return type="void" />
			<param index="0" name="name" type="String" />
			<description>
				Sets the name of the spectator server. This is only used if spectator port is nonzero.
			</description>
		</method>
		<method name="setTimeCreatedDateRange">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="start" type="int" />
			<param index="2" name="end" type="int" />
			<description>
				Set the time range this item was created.
			</description>
		</method>
		<method name="setTimeUpdatedDateRange">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="start" type="int" />
			<param index="2" name="end" type="int" />
			<description>
				Set the time range this item was updated.
			</description>
		</method>
		<method name="setUserAchievement">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<description>
				Unlocks an achievement for the specified user.
			</description>
		</method>
		<method name="setUserItemVote">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<param index="1" name="vote_up" type="bool" />
			<description>
				Allows the user to rate a workshop item up or down.
				Triggers a [signal SteamServer.set_user_item_vote] callback.
			</description>
		</method>
		<method name="setUserStatFloat">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="stat" type="float" />
			<description>
				Sets / updates the value of a given stat for the specified user.
			</description>
		</method>
		<method name="setUserStatInt">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="stat" type="int" />
			<description>
				Sets / updates the value of a given stat for the specified user.
			</description>
		</method>
		<method name="showWorkshopEULA">
			<return type="bool" />
			<description>
				Show the app's latest Workshop EULA to the user in an overlay window, where they can accept it or not.
			</description>
		</method>
		<method name="startItemUpdate">
			<return type="int" />
			<param index="0" name="app_id" type="int" />
			<param index="1" name="file_id" type="int" />
			<description>
				Starts the item update process.
				This gets you a handle that you can use to modify the item before finally sending off the update to the server with [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="startPlaytimeTracking">
			<return type="void" />
			<param index="0" name="published_file_ids" type="Array" />
			<description>
				Start tracking playtime on a set of workshop items.
				When your app shuts down, playtime tracking will automatically stop.
				Triggers a [signal SteamServer.start_playtime_tracking] callback.
			</description>
		</method>
		<method name="startPurchase">
			<return type="void" />
			<param index="0" name="items" type="PackedInt64Array" />
			<param index="1" name="quantity" type="PackedInt32Array" />
			<description>
				Starts the purchase process for the user, given a "shopping cart" of item definitions that the user would like to buy. The user will be prompted in the Steam Overlay to complete the purchase in their local currency, funding their Steam Wallet if necessary, etc.
				If the purchase process was started successfully, then order_id and transaction_id will be valid in the [signal SteamServer.inventory_start_purchase_result] call result.
				If the user authorizes the transaction and completes the purchase, then the callback [signal SteamServer.inventory_result_ready] will be triggered and you can then retrieve what new items the user has acquired.
				Triggers a [signal SteamServer.inventory_start_purchase_result] callback.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the inventory result for when you are done with it.
			</description>
		</method>
		<method name="startUpdateProperties">
			<return type="void" />
			<description>
				Starts a transaction request to update dynamic properties on items for the current user. This call is rate-limited by user, so property modifications should be batched as much as possible (e.g. at the end of a map or game session). After calling [method SteamServer.setProperty] or [method SteamServer.removeProperty] for all the items that you want to modify, you will need to call [method SteamServer.submitUpdateProperties] to send the request to the Steam servers. A [signal SteamServer.inventory_result_ready] callback will be fired with the results of the operation.
			</description>
		</method>
		<method name="stopPlaytimeTracking">
			<return type="void" />
			<param index="0" name="published_file_ids" type="Array" />
			<description>
				Stop tracking playtime on a set of workshop items.
				When your app shuts down, playtime tracking will automatically stop.
				Triggers a [signal SteamServer.stop_playtime_tracking] callback.
			</description>
		</method>
		<method name="stopPlaytimeTrackingForAllItems">
			<return type="void" />
			<description>
				Stop tracking playtime of all workshop items.
				When your app shuts down, playtime tracking will automatically stop.
				Triggers a [signal SteamServer.stop_playtime_tracking] callback.
			</description>
		</method>
		<method name="storeUserStats">
			<return type="void" />
			<param index="0" name="steam_id" type="int" />
			<description>
				Send the changed stats and achievements data to the server for permanent storage for the specified user.
			</description>
		</method>
		<method name="submitItemUpdate">
			<return type="void" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="change_note" type="String" />
			<description>
				Uploads the changes made to an item to the Steam Workshop.
				You can track the progress of an item update with [method SteamServer.getItemUpdateProgress].
				Triggers a [signal SteamServer.item_updated] callback.
			</description>
		</method>
		<method name="submitUpdateProperties">
			<return type="int" />
			<param index="0" name="this_inventory_update_handle" type="int" default="0" />
			<description>
				Submits the transaction request to modify dynamic properties on items for the current user. See [method SteamServer.startUpdateProperties].
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] You must call [method SteamServer.destroyResult] on the provided inventory result for when you are done with it.
			</description>
		</method>
		<method name="subscribeItem">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Subscribe to a workshop item. It will be downloaded and installed as soon as possible.
				Triggers a [signal SteamServer.subscribe_item] callback.
			</description>
		</method>
		<method name="suspendDownloads">
			<return type="void" />
			<param index="0" name="suspend" type="bool" />
			<description>
				Suspends and resumes all workshop downloads.
				If you call this with suspend set to true then downloads will be suspended until you resume them by setting suspend to false or when the game ends.
			</description>
		</method>
		<method name="transferItemQuantity">
			<return type="int" />
			<param index="0" name="item_id" type="int" />
			<param index="1" name="quantity" type="int" />
			<param index="2" name="item_destination" type="int" />
			<param index="3" name="split" type="bool" />
			<description>
				Transfer items between stacks within a user's inventory.
				This can be used to stack, split, and moving items. The source and destination items must have the same itemdef id. To move items onto a destination stack specify the source, the quantity to move, and the destination item id. To split an existing stack, pass -1 into item_destination. A new item stack will be generated with the requested quantity.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
				[b]Note:[/b] Tradability/marketability restrictions are copied along with transferred items. The destination stack receives the latest tradability/marketability date of any item in its composition.
			</description>
		</method>
		<method name="triggerItemDrop">
			<return type="int" />
			<param index="0" name="definition" type="int" />
			<description>
				Trigger an item drop if the user has played a long enough period of time.
				This period can be customized in two places:
				At the application level within Inventory Service: Playtime Item Grants. This will automatically apply to all "playtimegenerator" items that do not specify any overrides.
				In an individual "playtimegenerator" item definition. The settings would take precedence over any application-level settings.
				Only item definitions which are marked as "playtime item generators" can be spawned. Typically this function should be called at the end of a game or level or match or any point of significance in the game in which an item drop could occur. The granularity of the playtime generator settings is in minutes, so calling it more frequently than minutes is not useful and will be rate limited in the Steam client. The Steam servers will perform playtime accounting to prevent too-frequent drops. The servers will also manage adding the item to the players inventory.
				The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
			</description>
		</method>
		<method name="unsubscribeItem">
			<return type="void" />
			<param index="0" name="published_file_id" type="int" />
			<description>
				Unsubscribe from a workshop item. This will result in the item being removed after the game quits.
				Triggers a [signal SteamServer.unsubscribe_item] callback.
			</description>
		</method>
		<method name="updateItemPreviewFile">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="preview_file" type="String" />
			<description>
				Updates an additional video preview from YouTube for the item.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="updateItemPreviewVideo">
			<return type="bool" />
			<param index="0" name="update_handle" type="int" />
			<param index="1" name="index" type="int" />
			<param index="2" name="video_id" type="String" />
			<description>
				Updates an additional video preview from YouTube for the item.
				[b]Note:[/b] This must be set before you submit the UGC update handle using [method SteamServer.submitItemUpdate].
			</description>
		</method>
		<method name="updateUserAvgRateStat">
			<return type="bool" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="name" type="String" />
			<param index="2" name="this_session" type="float" />
			<param index="3" name="session_length" type="float" />
			<description>
				Updates an AVGRATE stat with new values for the specified user.
			</description>
		</method>
		<method name="userHasLicenceForApp">
			<return type="int" />
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="app_id" type="int" />
			<description>
				Checks if the user owns a specific piece of Downloadable Content (DLC).
				This can only be called after sending the users auth ticket to [method SteamServer.beginAuthSession].
			</description>
		</method>
		<method name="wasRestartRequested">
			<return type="bool" />
			<description>
				Checks if the master server has alerted us that we are out of date.
				This reverts back to false after calling this function.
			</description>
		</method>
	</methods>
	<members>
		<member name="inventory_handle" type="int" setter="set_inventory_handle" getter="get_inventory_handle" default="0">
		</member>
		<member name="inventory_update_handle" type="int" setter="set_inventory_update_handle" getter="get_inventory_update_handle" default="0">
		</member>
	</members>
	<signals>
		<signal name="add_app_dependency_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="app_id" type="int" />
			<description>
				The result of a call to [method SteamServer.addAppDependency].
			</description>
		</signal>
		<signal name="add_ugc_dependency_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="child_id" type="int" />
			<description>
				The result of a call to [method SteamServer.addAppDependency].
			</description>
		</signal>
		<signal name="associate_clan">
			<param index="0" name="result" type="int" />
			<description>
				Sent as a reply to [method SteamServer.associateWithClan].
			</description>
		</signal>
		<signal name="client_approved">
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="owner_id" type="int" />
			<description>
				Client has been approved to connect to this game server.
			</description>
		</signal>
		<signal name="client_denied">
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="reason" type="int" />
			<description>
				Client has been denied to connection to this game server.
			</description>
		</signal>
		<signal name="client_group_status">
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="group_id" type="int" />
			<param index="2" name="member" type="bool" />
			<param index="3" name="officer" type="bool" />
			<description>
				Sent as a reply to [method SteamServer.requestUserGroupStatus].
			</description>
		</signal>
		<signal name="client_kick">
			<param index="0" name="steam_id" type="int" />
			<param index="1" name="reason" type="int" />
			<description>
				Request the game server should kick the user.
			</description>
		</signal>
		<signal name="download_ugc_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="download_data" type="Dictionary" />
			<description>
				Response when downloading UGC.
				The returned dictionary has the following keys:
				[codeblock]
				┠╴handle (int)
				┠╴app_id (int)
				┠╴size (int)
				┠╴filename (string)
				┖╴owner_id (int)
				[/codeblock]
			</description>
		</signal>
		<signal name="fake_ip_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="remote_fake_steam_id" type="int" />
			<param index="2" name="fake_ip" type="String" />
			<param index="3" name="port_list" type="Array" />
			<description>
				A struct used to describe a "fake IP" we have been assigned to use as an identifier. This callback is posted when [method SteamServer.beginAsyncRequestFakeIP]completes.
			</description>
		</signal>
		<signal name="file_read_async_complete">
			<param index="0" name="file_read" type="Dictionary" />
			<description>
				Response when reading a file with [method SteamServer.fileReadAsync].
			</description>
		</signal>
		<signal name="file_share_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="handle" type="int" />
			<param index="2" name="name" type="String" />
			<description>
				Response to a file being shared.
			</description>
		</signal>
		<signal name="file_write_async_complete">
			<param index="0" name="result" type="int" />
			<description>
				Response when writing a file asyncrounously with [method SteamServer.fileWriteAsync].
			</description>
		</signal>
		<signal name="get_app_dependencies_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="app_dependencies" type="int" />
			<param index="3" name="total_app_dependencies" type="int" />
			<description>
				Called when getting the app dependencies for an item.
			</description>
		</signal>
		<signal name="get_item_vote_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="vote_up" type="bool" />
			<param index="3" name="vote_down" type="bool" />
			<param index="4" name="vote_skipped" type="bool" />
			<description>
				Called when getting the users vote status on an item.
			</description>
		</signal>
		<signal name="http_request_completed">
			<param index="0" name="cookie_handle" type="int" />
			<param index="1" name="context_value" type="int" />
			<param index="2" name="request_success" type="bool" />
			<param index="3" name="status_code" type="int" />
			<param index="4" name="body_size" type="int" />
			<description>
				Result when an HTTP request completes. If you're using [method SteamServer.getHTTPStreamingResponseBodyData] then you should be using the [signal SteamServer.http_request_headers_received] or [signal SteamServer.http_request_data_received].
			</description>
		</signal>
		<signal name="http_request_data_received">
			<param index="0" name="cookie_handle" type="int" />
			<param index="1" name="context_value" type="int" />
			<param index="2" name="offset" type="int" />
			<param index="3" name="bytes_received" type="int" />
			<description>
				Triggered when a chunk of data is received from a streaming HTTP request.
			</description>
		</signal>
		<signal name="http_request_headers_received">
			<param index="0" name="cookie_handle" type="int" />
			<param index="1" name="context_value" type="int" />
			<description>
				Triggered when HTTP headers are received from a streaming HTTP request.
			</description>
		</signal>
		<signal name="inventory_definition_update">
			<param index="0" name="definitions" type="Array" />
			<description>
				This callback is triggered whenever item definitions have been updated, which could be in response to [method SteamServer.loadItemDefinitions] or any time new item definitions are available (eg, from the dynamic addition of new item types while players are still in-game).
			</description>
		</signal>
		<signal name="inventory_eligible_promo_item">
			<param index="0" name="result" type="int" />
			<param index="1" name="cached" type="bool" />
			<param index="2" name="definitions" type="Array" />
			<description>
				Returned when you have requested the list of "eligible" promo items that can be manually granted to the given user. These are promo items of type "manual" that won't be granted automatically.
			</description>
		</signal>
		<signal name="inventory_full_update">
			<param index="0" name="inventory_handle" type="int" />
			<description>
				Triggered when [method SteamServer.getAllItems] successfully returns a result which is newer / fresher than the last known result. (It will not trigger if the inventory hasn't changed, or if results from two overlapping calls are reversed in flight and the earlier result is already known to be stale/out-of-date.) The regular [method SteamServer.inventory_result_ready] callback will still be triggered immediately afterwards; this is an additional notification for your convenience.
			</description>
		</signal>
		<signal name="inventory_request_prices_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="currency" type="String" />
			<description>
				Returned after [method SteamServer.requestPrices] is called.
			</description>
		</signal>
		<signal name="inventory_result_ready">
			<param index="0" name="result" type="int" />
			<param index="1" name="inventory_handle" type="int" />
			<description>
			</description>
		</signal>
		<signal name="inventory_start_purchase_result">
			<param index="0" name="result" type="String" />
			<param index="1" name="order_id" type="int" />
			<param index="2" name="transaction_id" type="int" />
			<description>
				This is fired whenever an inventory result transitions from k_EResultPending to any other completed state, see [method SteamServer.getResultStatus] for the complete list of states. There will always be exactly one callback per handle.
			</description>
		</signal>
		<signal name="item_created">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="accept_tos" type="bool" />
			<description>
				Called when a new workshop item has been created.
			</description>
		</signal>
		<signal name="item_deleted">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<description>
				Called when an attempt at deleting an item completes.
			</description>
		</signal>
		<signal name="item_downloaded">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="app_id" type="int" />
			<description>
				Called when a workshop item has been downloaded.
			</description>
		</signal>
		<signal name="item_installed">
			<param index="0" name="app_id" type="int" />
			<param index="1" name="file_id" type="int" />
			<description>
				Called when a workshop item has been installed or updated.
			</description>
		</signal>
		<signal name="item_updated">
			<param index="0" name="result" type="int" />
			<param index="1" name="need_to_accept_tos" type="bool" />
			<description>
				Called when an item update has completed.
				Emits signal in response to function [method SteamServer.submitItemUpdate].
			</description>
		</signal>
		<signal name="local_file_changed">
			<description>
				One or more files for this app have changed locally after syncing to remote session changes.
				[b]Note:[/b] only posted if this happens during the local app session.
			</description>
		</signal>
		<signal name="network_authentication_status">
			<param index="0" name="available" type="int" />
			<param index="1" name="debug_message" type="String" />
			<description>
				This callback is posted whenever the state of our readiness changes.
			</description>
		</signal>
		<signal name="network_connection_status_changed">
			<param index="0" name="connect_handle" type="int" />
			<param index="1" name="connection" type="Dictionary" />
			<param index="2" name="old_state" type="int" />
			<description>
				This callback is posted whenever a connection is created, destroyed, or changes state. The m_info field will contain a complete description of the connection at the time the change occurred and the callback was posted. In particular, m_info.m_eState will have the new connection state.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴identity (string)
				┠╴user_data (int)
				┠╴listen_socket (int)
				┠╴remote_address (string)
				┠╴remote_pop (int)
				┠╴pop_relay (int)
				┠╴connection_state (int)
				┠╴end_reason (string)
				┠╴end_debug (string)
				┖╴debug_description (string)
				[/codeblock]
			</description>
		</signal>
		<signal name="network_messages_session_failed">
			<param index="0" name="reason" type="int" />
			<description>
				Posted when we fail to establish a connection, or we detect that communications have been disrupted it an unusual way.
			</description>
		</signal>
		<signal name="network_messages_session_request">
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Posted when a remote host is sending us a message, and we do not already have a session with them.
			</description>
		</signal>
		<signal name="p2p_session_connect_fail">
			<param index="0" name="remote_steam_id" type="int" />
			<param index="1" name="session_error" type="int" />
			<description>
				Called when a user sends a packet and it fails.
			</description>
		</signal>
		<signal name="p2p_session_request">
			<param index="0" name="remote_steam_id" type="int" />
			<description>
				Called when a user sends a packet.
			</description>
		</signal>
		<signal name="player_compat">
			<param index="0" name="result" type="int" />
			<param index="1" name="players_dont_like_candidate" type="int" />
			<param index="2" name="players_candidate_doesnt_like" type="int" />
			<param index="3" name="clan_players_dont_like_candidate" type="int" />
			<param index="4" name="steam_id" type="int" />
			<description>
				Sent as a reply to [method SteamServer.computeNewPlayerCompatibility].
			</description>
		</signal>
		<signal name="policy_response">
			<param index="0" name="secure" type="int" />
			<description>
				Received when the game server requests to be displayed as secure (VAC protected).
				[b]Secure[/b] is true if the game server should display itself as secure to users, false otherwise.
			</description>
		</signal>
		<signal name="relay_network_status">
			<param index="0" name="available" type="int" />
			<param index="1" name="ping_measurement" type="int" />
			<param index="2" name="available_config" type="int" />
			<param index="3" name="available_relay" type="int" />
			<param index="4" name="debug_message" type="String" />
			<description>
				A struct used to describe our readiness to use the relay network.
			</description>
		</signal>
		<signal name="remove_app_dependency_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="app_id" type="int" />
			<description>
				Purpose: The result of a call to [method SteamServer.removeAppDependency].
			</description>
		</signal>
		<signal name="remove_ugc_dependency_result">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="child_id" type="int" />
			<description>
				Purpose: The result of a call to [method SteamServer.removeDependency].
			</description>
		</signal>
		<signal name="server_connect_failure">
			<param index="0" name="result" type="int" />
			<param index="1" name="retrying" type="bool" />
			<description>
				Called when a connection attempt has failed. This will occur periodically if the Steam client is not connected, and has failed when retrying to establish a connection.
			</description>
		</signal>
		<signal name="server_connected">
			<description>
				Called when a connections to the Steam back-end has been established. This means the Steam client now has a working connection to the Steam servers. Usually this will have occurred before the game has launched, and should only be seen if the user has dropped connection due to a networking issue or a Steam server update.
			</description>
		</signal>
		<signal name="server_disconnected">
			<param index="0" name="result" type="int" />
			<description>
				Called if the client has lost connection to the Steam servers. Real-time services will be disabled until a matching [signal SteamServer.serversConnected_t has been posted.
			</description>
		</signal>
		<signal name="set_user_item_vote">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="vote_up" type="bool" />
			<description>
				Called when the user has voted on an item.
			</description>
		</signal>
		<signal name="start_playtime_tracking">
			<param index="0" name="result" type="int" />
			<description>
				Called when workshop item playtime tracking has started.
			</description>
		</signal>
		<signal name="stats_received">
			<param index="0" name="result" type="int" />
			<param index="1" name="steam_id" type="int" />
			<description>
				Called when the latest stats and achievements for a specific user (including the local user) have been received from the server.
			</description>
		</signal>
		<signal name="stats_stored">
			<param index="0" name="result" type="int" />
			<param index="1" name="steam_id" type="int" />
			<description>
				Result of a request to store the user stats.
			</description>
		</signal>
		<signal name="stats_unloaded">
			<param index="0" name="steam_id" type="int" />
			<description>
				Callback indicating that a user's stats have been unloaded.
				Call [method SteamServer.requestUserStats] again to access stats for this user.

			</description>
		</signal>
		<signal name="steamworks_error">
			<param index="0" name="failed_signal" type="String" />
			<param index="1" name="io failure" type="String" />
			<description>
				Intended to serve as generic error messaging for failed call results.
			</description>
		</signal>
		<signal name="stop_playtime_tracking">
			<param index="0" name="result" type="int" />
			<description>
				Called when workshop item playtime tracking has stopped.
			</description>
		</signal>
		<signal name="subscribe_item">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<description>
				Called when a player attempts to subscribe to a Workshop item.
				[b]Deprecated:[/b] only used with the deprecated Remote Storage based Workshop API.
			</description>
		</signal>
		<signal name="ugc_query_completed">
			<param index="0" name="handle" type="int" />
			<param index="1" name="result" type="int" />
			<param index="2" name="results_returned" type="int" />
			<param index="3" name="total_matching" type="int" />
			<param index="4" name="cached" type="bool" />
			<description>
				Called when a UGC query request completes.
			</description>
		</signal>
		<signal name="unsubscribe_item">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<description>
				Called when a player attempts to unsubscribe from a Workshop item.
				[b]Deprecated:[/b] only used with the deprecated Remote Storage based Workshop API.
			</description>
		</signal>
		<signal name="user_favorite_items_list_changed">
			<param index="0" name="result" type="int" />
			<param index="1" name="file_id" type="int" />
			<param index="2" name="was_add_request" type="bool" />
			<description>
				Called when the user has added or removed an item to/from their favorites.
			</description>
		</signal>
		<signal name="user_subscribed_items_list_changed">
			<param index="0" name="app_id" type="int" />
			<description>
				Signal that the list of subscribed items changed.
			</description>
		</signal>
		<signal name="workshop_eula_status">
			<param index="0" name="result" type="int" />
			<param index="1" name="app_id" type="int" />
			<param index="2" name="eula_data" type="Dictionary" />
			<description>
				Status of the user's acceptable/rejection of the app's specific Workshop EULA.
				The returned dictionary contains the following keys:
				[codeblock]
				┠╴version (int)
				┠╴action (int)
				┠╴accepted (bool)
				┖╴needs_action (bool)
				[/codeblock]
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="ACCOUNT_ID_INVALID" value="0">
		</constant>
		<constant name="API_CALL_INVALID" value="0">
		</constant>
		<constant name="APP_ID_INVALID" value="0">
		</constant>
		<constant name="AUTH_TICKET_INVALID" value="0">
		</constant>
		<constant name="DEPOT_ID_INVALID" value="0">
		</constant>
		<constant name="GAME_EXTRA_INFO_MAX" value="64">
		</constant>
		<constant name="INVALID_BREAKPAD_HANDLE" value="0">
		</constant>
		<constant name="QUERY_PORT_ERROR" value="65534">
		</constant>
		<constant name="QUERY_PORT_NOT_INITIALIZED" value="65535">
		</constant>
		<constant name="STEAM_ACCOUNT_ID_MASK" value="4294967295">
		</constant>
		<constant name="STEAM_ACCOUNT_INSTANCE_MASK" value="1048575">
		</constant>
		<constant name="STEAM_BUFFER_SIZE" value="255">
		</constant>
		<constant name="STEAM_LARGE_BUFFER_SIZE" value="8160">
		</constant>
		<constant name="STEAM_MAX_ERROR_MESSAGE" value="1024">
		</constant>
		<constant name="STEAM_USER_CONSOLE_INSTANCE" value="2">
		</constant>
		<constant name="STEAM_USER_DESKTOP_INSTANCE" value="1">
		</constant>
		<constant name="STEAM_USER_WEB_INSTANCE" value="4">
		</constant>
		<constant name="QUERY_PORT_SHARED" value="65535">
		</constant>
		<constant name="HTTPCOOKIE_INVALID_HANDLE" value="0">
		</constant>
		<constant name="HTTPREQUEST_INVALID_HANDLE" value="0">
		</constant>
		<constant name="INVENTORY_RESULT_INVALID" value="-1">
		</constant>
		<constant name="ITEM_INSTANCE_ID_INVALID" value="-1">
		</constant>
		<constant name="MAX_STEAM_PACKET_SIZE" value="524288">
		</constant>
		<constant name="LISTEN_SOCKET_INVALID" value="0">
		</constant>
		<constant name="MAX_NETWORKING_ERROR_MESSAGE" value="1024">
		</constant>
		<constant name="MAX_NETWORKING_PING_LOCATION_STRING" value="1024">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DEFAULT" value="-1">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DISABLE" value="0">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_RELAY" value="1">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PRIVATE" value="2">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PUBLIC" value="4">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_ALL" value="2147483647">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_UNAUTHENTICATED" value="1">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_UNENCRYPTED" value="2">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_LOOPBACK_BUFFERS" value="4">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_FAST" value="8">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_RELAYED" value="16">
		</constant>
		<constant name="NETWORKING_CONNECTION_INFO_FLAG_DUALWIFI" value="32">
		</constant>
		<constant name="NETWORKING_CONNECTION_INVALID" value="0">
		</constant>
		<constant name="NETWORKING_MAX_CONNECTION_APP_NAME" value="32">
		</constant>
		<constant name="NETWORKING_MAX_CONNECTION_CLOSE_REASON" value="128">
		</constant>
		<constant name="NETWORKING_MAX_CONNECTION_DESCRIPTION" value="128">
		</constant>
		<constant name="NETWORKING_PING_FAILED" value="-1">
		</constant>
		<constant name="NETWORKING_PING_UNKNOWN" value="-2">
		</constant>
		<constant name="NETWORKING_SEND_UNRELIABLE" value="0">
		</constant>
		<constant name="NETWORKING_SEND_NO_NAGLE" value="1">
		</constant>
		<constant name="NETWORKING_SEND_URELIABLE_NO_NAGLE" value="1">
		</constant>
		<constant name="NETWORKING_SEND_NO_DELAY" value="4">
		</constant>
		<constant name="NETWORKING_SEND_UNRELIABLE_NO_DELAY" value="5">
		</constant>
		<constant name="NETWORKING_SEND_RELIABLE" value="8">
		</constant>
		<constant name="NETWORKING_SEND_RELIABLE_NO_NAGLE" value="9">
		</constant>
		<constant name="NETWORKING_SEND_USE_CURRENT_THREAD" value="16">
		</constant>
		<constant name="NETWORKING_SEND_AUTORESTART_BROKEN_SESSION" value="32">
		</constant>
		<constant name="DEVELOPER_METADATA_MAX" value="5000">
		</constant>
		<constant name="NUM_UGC_RESULTS_PER_PAGE" value="50">
		</constant>
		<constant name="UGC_QUERY_HANDLE_INVALID" value="-1">
		</constant>
		<constant name="UGC_UPDATE_HANDLE_INVALID" value="-1">
		</constant>
		<constant name="ACCOUNT_TYPE_INVALID" value="0" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_INDIVIDUAL" value="1" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_MULTISEAT" value="2" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_GAME_SERVER" value="3" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_ANON_GAME_SERVER" value="4" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_PENDING" value="5" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_CONTENT_SERVER" value="6" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_CLAN" value="7" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_CHAT" value="8" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_CONSOLE_USER" value="9" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_ANON_USER" value="10" enum="AccountType">
		</constant>
		<constant name="ACCOUNT_TYPE_MAX" value="11" enum="AccountType">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_OK" value="0" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_USER_NOT_CONNECTED_TO_STEAM" value="1" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_NO_LICENSE_OR_EXPIRED" value="2" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_VAC_BANNED" value="3" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_LOGGED_IN_ELSEWHERE" value="4" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_VAC_CHECK_TIMED_OUT" value="5" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_AUTH_TICKET_CANCELED" value="6" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_AUTH_TICKET_INVALID_ALREADY_USED" value="7" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_AUTH_TICKET_INVALID" value="8" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_PUBLISHER_ISSUED_BAN" value="9" enum="AuthSessionResponse">
		</constant>
		<constant name="AUTH_SESSION_RESPONSE_AUTH_TICKET_NETWORK_IDENTITY_FAILURE" value="10" enum="AuthSessionResponse">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_OK" value="0" enum="BeginAuthSessionResult">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_INVALID_TICKET" value="1" enum="BeginAuthSessionResult">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_DUPLICATE_REQUEST" value="2" enum="BeginAuthSessionResult">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_INVALID_VERSION" value="3" enum="BeginAuthSessionResult">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_GAME_MISMATCH" value="4" enum="BeginAuthSessionResult">
		</constant>
		<constant name="BEGIN_AUTH_SESSION_RESULT_EXPIRED_TICKET" value="5" enum="BeginAuthSessionResult">
		</constant>
		<constant name="DENY_INVALID" value="0" enum="DenyReason">
		</constant>
		<constant name="DENY_INVALID_VERSION" value="1" enum="DenyReason">
		</constant>
		<constant name="DENY_GENERIC" value="2" enum="DenyReason">
		</constant>
		<constant name="DENY_NOT_LOGGED_ON" value="3" enum="DenyReason">
		</constant>
		<constant name="DENY_NO_LICENSE" value="4" enum="DenyReason">
		</constant>
		<constant name="DENY_CHEATER" value="5" enum="DenyReason">
		</constant>
		<constant name="DENY_LOGGED_IN_ELSEWHERE" value="6" enum="DenyReason">
		</constant>
		<constant name="DENY_UNKNOWN_TEXT" value="7" enum="DenyReason">
		</constant>
		<constant name="DENY_INCOMPATIBLE_ANTI_CHEAT" value="8" enum="DenyReason">
		</constant>
		<constant name="DENY_MEMORY_CORRUPTION" value="9" enum="DenyReason">
		</constant>
		<constant name="DENY_INCOMPATIBLE_SOFTWARE" value="10" enum="DenyReason">
		</constant>
		<constant name="DENY_STEAM_CONNECTION_LOST" value="11" enum="DenyReason">
		</constant>
		<constant name="DENY_STEAM_CONNECTION_ERROR" value="12" enum="DenyReason">
		</constant>
		<constant name="DENY_STEAM_RESPONSE_TIMED_OUT" value="13" enum="DenyReason">
		</constant>
		<constant name="DENY_STEAM_VALIDATION_STALLED" value="14" enum="DenyReason">
		</constant>
		<constant name="DENY_STEAM_OWNER_LEFT_GUEST_USER" value="15" enum="DenyReason">
		</constant>
		<constant name="FILE_PATH_TYPE_INVALID" value="0" enum="FilePathType">
		</constant>
		<constant name="FILE_PATH_TYPE_ABSOLUTE" value="1" enum="FilePathType">
		</constant>
		<constant name="FILE_PATH_TYPE_API_FILENAME" value="2" enum="FilePathType">
		</constant>
		<constant name="GAME_TYPE_APP" value="0" enum="GameIDType">
		</constant>
		<constant name="GAME_TYPE_GAME_MOD" value="1" enum="GameIDType">
		</constant>
		<constant name="GAME_TYPE_SHORTCUT" value="2" enum="GameIDType">
		</constant>
		<constant name="GAME_TYPE_P2P" value="3" enum="GameIDType">
		</constant>
		<constant name="HTTP_METHOD_INVALID" value="0" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_GET" value="1" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_HEAD" value="2" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_POST" value="3" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_PUT" value="4" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_DELETE" value="5" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_OPTIONS" value="6" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_METHOD_PATCH" value="7" enum="HTTPMethod">
		</constant>
		<constant name="HTTP_STATUS_CODE_INVALID" value="0" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_100_CONTINUE" value="100" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_101_SWITCHING_PROTOCOLS" value="101" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_200_OK" value="200" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_201_CREATED" value="201" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_202_ACCEPTED" value="202" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_203_NON_AUTHORITATIVE" value="203" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_204_NO_CONTENT" value="204" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_205_RESET_CONTENT" value="205" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_206_PARTIAL_CONTENT" value="206" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_300_MULTIPLE_CHOICES" value="300" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_301_MOVED_PERMANENTLY" value="301" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_302_FOUND" value="302" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_303_SEE_OTHER" value="303" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_304_NOT_MODIFIED" value="304" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_305_USE_PROXY" value="305" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_307_TEMPORARY_REDIRECT" value="307" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_308_PERMANENT_REDIRECT" value="308" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_400_BAD_REQUEST" value="400" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_401_UNAUTHORIZED" value="401" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_402_PAYMENT_REQUIRED" value="402" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_403_FORBIDDEN" value="403" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_404_NOT_FOUND" value="404" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_405_METHOD_NOT_ALLOWED" value="405" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_406_NOT_ACCEPTABLE" value="406" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_407_PROXY_AUTH_REQUIRED" value="407" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_408_REQUEST_TIMEOUT" value="408" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_409_CONFLICT" value="409" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_410_GONE" value="410" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_411_LENGTH_REQUIRED" value="411" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_412_PRECONDITION_FAILED" value="412" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_413_REQUEST_ENTITY_TOO_LARGE" value="413" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_414_REQUEST_URI_TOO_LONG" value="414" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_415_UNSUPPORTED_MEDIA_TYPE" value="415" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE" value="416" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_417_EXPECTATION_FAILED" value="417" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_4XX_UNKNOWN" value="418" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_429_TOO_MANY_REQUESTS" value="429" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_444_CONNECTION_CLOSED" value="444" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_500_INTERNAL_SERVER_ERROR" value="500" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_501_NOT_IMPLEMENTED" value="501" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_502_BAD_GATEWAY" value="502" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_503_SERVICE_UNAVAILABLE" value="503" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_504_GATEWAY_TIMEOUT" value="504" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_505_HTTP_VERSION_NOT_SUPPORTED" value="505" enum="HTTPStatusCode">
		</constant>
		<constant name="HTTP_STATUS_CODE_5XX_UNKNOWN" value="599" enum="HTTPStatusCode">
		</constant>
		<constant name="IP_TYPE_IPV4" value="0" enum="IPType">
		</constant>
		<constant name="IP_TYPE_IPV6" value="1" enum="IPType">
		</constant>
		<constant name="STEAM_ITEM_NO_TRADE" value="1" enum="ItemFlags" is_bitfield="true">
		</constant>
		<constant name="STEAM_ITEM_REMOVED" value="256" enum="ItemFlags" is_bitfield="true">
		</constant>
		<constant name="STEAM_ITEM_CONSUMED" value="512" enum="ItemFlags" is_bitfield="true">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_IMAGE" value="0" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_YOUTUBE_VIDEO" value="1" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_SKETCHFAB" value="2" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_ENVIRONMENTMAP_HORIZONTAL_CROSS" value="3" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_ENVIRONMENTMAP_LAT_LONG" value="4" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_CLIP" value="5" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_PREVIEW_TYPE_RESERVED_MAX" value="255" enum="ItemPreviewType">
		</constant>
		<constant name="ITEM_STATE_NONE" value="0" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_SUBSCRIBED" value="1" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_LEGACY_ITEM" value="2" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_INSTALLED" value="4" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_NEEDS_UPDATE" value="8" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_DOWNLOADING" value="16" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_DOWNLOAD_PENDING" value="32" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATE_DISABLED_LOCALLY" value="64" enum="ItemState" is_bitfield="true">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_SUBSCRIPTIONS" value="0" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_FAVORITES" value="1" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_FOLLOWERS" value="2" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_UNIQUE_SUBSCRIPTIONS" value="3" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_UNIQUE_FAVORITES" value="4" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_UNIQUE_FOLLOWERS" value="5" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_UNIQUE_WEBSITE_VIEWS" value="6" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_REPORT_SCORE" value="7" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_SECONDS_PLAYED" value="8" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_PLAYTIME_SESSIONS" value="9" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_COMMENTS" value="10" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_SECONDS_PLAYED_DURING_TIME_PERIOD" value="11" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_STATISTIC_NUM_PLAYTIME_SESSIONS_DURING_TIME_PERIOD" value="12" enum="ItemStatistic">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_INVALID" value="0" enum="ItemUpdateStatus">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_PREPARING_CONFIG" value="1" enum="ItemUpdateStatus">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_PREPARING_CONTENT" value="2" enum="ItemUpdateStatus">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_UPLOADING_CONTENT" value="3" enum="ItemUpdateStatus">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_UPLOADING_PREVIEW_FILE" value="4" enum="ItemUpdateStatus">
		</constant>
		<constant name="ITEM_UPDATE_STATUS_COMMITTING_CHANGES" value="5" enum="ItemUpdateStatus">
		</constant>
		<constant name="LOCAL_FILE_CHANGE_INVALID" value="0" enum="LocalFileChange">
		</constant>
		<constant name="LOCAL_FILE_CHANGE_FILE_UPDATED" value="1" enum="LocalFileChange">
		</constant>
		<constant name="LOCAL_FILE_CHANGE_FILE_DELETED" value="2" enum="LocalFileChange">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_CANNOT_TRY" value="-102" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_FAILED" value="-101" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_PREVIOUSLY" value="-100" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_RETRYING" value="-10" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_NEVER_TRIED" value="1" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_WAITING" value="2" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_ATTEMPTING" value="3" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_CURRENT" value="100" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_UNKNOWN" value="0" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_AVAILABILITY_FORCE_32BIT" value="2147483647" enum="NetworkingAvailability">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_INT32" value="1" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_INT64" value="2" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_FLOAT" value="3" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_STRING" value="4" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_FUNCTION_PTR" value="5" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_TYPE_FORCE_32BIT" value="2147483647" enum="NetworkingConfigDataType">
		</constant>
		<constant name="NETWORKING_CONFIG_SCOPE_GLOBAL" value="1" enum="NetworkingConfigScope">
		</constant>
		<constant name="NETWORKING_CONFIG_SCOPE_SOCKETS_INTERFACE" value="2" enum="NetworkingConfigScope">
		</constant>
		<constant name="NETWORKING_CONFIG_SCOPE_LISTEN_SOCKET" value="3" enum="NetworkingConfigScope">
		</constant>
		<constant name="NETWORKING_CONFIG_SCOPE_CONNECTION" value="4" enum="NetworkingConfigScope">
		</constant>
		<constant name="NETWORKING_CONFIG_SCOPE_FORCE_32BIT" value="2147483647" enum="NetworkingConfigScope">
		</constant>
		<constant name="NETWORKING_CONFIG_INVALID" value="0" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_LOSS_SEND" value="2" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_LOSS_RECV" value="3" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_LAG_SEND" value="4" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_LAG_RECV" value="5" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_REORDER_SEND" value="6" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_REORDER_RECV" value="7" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_REORDER_TIME" value="8" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_DUP_SEND" value="26" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_DUP_REVC" value="27" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_PACKET_DUP_TIME_MAX" value="28" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_PACKET_TRACE_MAX_BYTES" value="41" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_RATE_LIMIT_SEND_RATE" value="42" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_RATE_LIMIT_SEND_BURST" value="43" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_RATE_LIMIT_RECV_RATE" value="44" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_FAKE_RATE_LIMIT_RECV_BURST" value="45" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_OUT_OF_ORDER_CORRECTION_WINDOW_MICROSECONDS" value="51" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CONNECTION_USER_DATA" value="40" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_TIMEOUT_INITIAL" value="24" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_TIMEOUT_CONNECTED" value="25" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SEND_BUFFER_SIZE" value="9" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_RECV_BUFFER_SIZE" value="47" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_RECV_BUFFER_MESSAGES" value="48" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_RECV_MAX_MESSAGE_SIZE" value="49" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_RECV_MAX_SEGMENTS_PER_PACKET" value="50" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SEND_RATE_MIN" value="10" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SEND_RATE_MAX" value="11" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_NAGLE_TIME" value="12" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_IP_ALLOW_WITHOUT_AUTH" value="23" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_IP_LOCAL_HOST_ALLOW_WITHOUT_AUTH" value="52" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_MTU_PACKET_SIZE" value="32" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_MTU_DATA_SIZE" value="33" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_UNENCRYPTED" value="34" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SYMMETRIC_CONNECT" value="37" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOCAL_VIRTUAL_PORT" value="38" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_DUAL_WIFI_ENABLE" value="39" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_ENABLE_DIAGNOSTICS_UI" value="46" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_CONSEC_PING_TIMEOUT_FAIL_INITIAL" value="19" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_CONSEC_PING_TIMEOUT_FAIL" value="20" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_MIN_PINGS_BEFORE_PING_ACCURATE" value="21" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_SINGLE_SOCKET" value="22" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_FORCE_RELAY_CLUSTER" value="29" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_DEV_TICKET" value="30" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_FORCE_PROXY_ADDR" value="31" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_FAKE_CLUSTER_PING" value="36" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_SDR_CLIENT_LIMIT_PING_PROBES_TO_NEAREST_N" value="60" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_ACK_RTT" value="13" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_PACKET_DECODE" value="14" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_MESSAGE" value="15" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_PACKET_GAPS" value="16" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_P2P_RENDEZVOUS" value="17" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_LOG_LEVEL_SRD_RELAY_PINGS" value="18" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_CONNECTION_STATUS_CHANGED" value="201" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_AUTH_STATUS_CHANGED" value="202" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_RELAY_NETWORK_STATUS_CHANGED" value="203" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_MESSAGE_SESSION_REQUEST" value="204" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_MESSAGES_SESSION_FAILED" value="205" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_CREATE_CONNECTION_SIGNALING" value="206" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_CALLBACK_FAKE_IP_RESULT" value="207" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_STUN_SERVER_LIST" value="103" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_ENABLE" value="104" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PENALTY" value="105" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_SDR_PENALTY" value="106" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TURN_SERVER_LIST" value="107" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TURN_uSER_LIST" value="108" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TURN_PASS_LIST" value="109" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_P2P_TRANSPORT_ICE_IMPLEMENTATION" value="110" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_ECN" value="999" enum="NetworkingConfigValue">
		</constant>
		<constant name="NETWORKING_CONFIG_VALUE_FORCE32BIT" value="2147483647" enum="NetworkingConfigValue">
		</constant>
		<constant name="CONNECTION_END_INVALID" value="0" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_MIN" value="1000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_GENERIC" value="1000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_MAX" value="1999" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_EXCEPTION_MIN" value="2000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_EXCEPTION_GENERIC" value="2000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_APP_EXCEPTION_MAX" value="2999" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_MIN" value="3000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_OFFLINE_MODE" value="3001" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_MANY_RELAY_CONNECTIVITY" value="3002" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_HOSTED_SERVER_PRIMARY_RELAY" value="3003" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_NETWORK_CONFIG" value="3004" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_RIGHTS" value="3005" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_NO_PUBLIC_ADDRESS" value="3006" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_LOCAL_MAX" value="3999" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOVE_MIN" value="4000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOTE_TIMEOUT" value="4001" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOTE_BAD_CRYPT" value="4002" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOTE_BAD_CERT" value="4003" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_BAD_PROTOCOL_VERSION" value="4006" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOTE_P2P_ICE_NO_PUBLIC_ADDRESSES" value="4007" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_REMOTE_MAX" value="4999" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_MIN" value="5000" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_GENERIC" value="5001" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_INTERNAL_ERROR" value="5002" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_TIMEOUT" value="5003" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_STEAM_CONNECTIVITY" value="5005" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_NO_RELAY_SESSIONS_TO_CLIENT" value="5006" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_P2P_RENDEZVOUS" value="5008" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_P2P_NAT_FIREWALL" value="5009" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_PEER_SENT_NO_CONNECTION" value="5010" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_MISC_MAX" value="5999" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_END_FORCE32BIT" value="2147483647" enum="NetworkingConnectionEnd">
		</constant>
		<constant name="CONNECTION_STATE_NONE" value="0" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_CONNECTING" value="1" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_FINDING_ROUTE" value="2" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_CONNECTED" value="3" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_CLOSED_BY_PEER" value="4" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_PROBLEM_DETECTED_LOCALLY" value="5" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_FIN_WAIT" value="-1" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_LINGER" value="-2" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_DEAD" value="-3" enum="NetworkingConnectionState">
		</constant>
		<constant name="CONNECTION_STATE_FORCE_32BIT" value="2147483647" enum="NetworkingConnectionState">
		</constant>
		<constant name="FAKE_IP_TYPE_INVALID" value="0" enum="NetworkingFakeIPType">
		</constant>
		<constant name="FAKE_IP_TYPE_NOT_FAKE" value="1" enum="NetworkingFakeIPType">
		</constant>
		<constant name="FAKE_IP_TYPE_GLOBAL_IPV4" value="2" enum="NetworkingFakeIPType">
		</constant>
		<constant name="FAKE_IP_TYPE_LOCAL_IPV4" value="3" enum="NetworkingFakeIPType">
		</constant>
		<constant name="FAKE_IP_TYPE_FORCE32BIT" value="2147483647" enum="NetworkingFakeIPType">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_BAD_VALUE" value="-1" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_BAD_SCOPE_OBJ" value="-2" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_BUFFER_TOO_SMALL" value="-3" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_OK" value="1" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_OK_INHERITED" value="2" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="NETWORKING_GET_CONFIG_VALUE_FORCE_32BIT" value="2147483647" enum="NetworkingGetConfigValueResult">
		</constant>
		<constant name="IDENTITY_TYPE_INVALID" value="0" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_STEAMID" value="16" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_IP_ADDRESS" value="1" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_GENERIC_STRING" value="2" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_GENERIC_BYTES" value="3" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_UNKNOWN_TYPE" value="4" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_XBOX_PAIRWISE" value="17" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_SONY_PSN" value="18" enum="NetworkingIdentityType">
		</constant>
		<constant name="IDENTITY_TYPE_FORCE_32BIT" value="2147483647" enum="NetworkingIdentityType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_NONE" value="0" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_BUG" value="1" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_ERROR" value="2" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_IMPORTANT" value="3" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_WARNING" value="4" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_MSG" value="5" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_VERBOSE" value="6" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_DEBUG" value="7" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_EVERYTHING" value="8" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="NETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_FORCE_32BIT" value="2147483647" enum="NetworkingSocketsDebugOutputType">
		</constant>
		<constant name="P2P_SEND_UNRELIABLE" value="0" enum="P2PSend">
		</constant>
		<constant name="P2P_SEND_UNRELIABLE_NO_DELAY" value="1" enum="P2PSend">
		</constant>
		<constant name="P2P_SEND_RELIABLE" value="2" enum="P2PSend">
		</constant>
		<constant name="P2P_SEND_RELIABLE_WITH_BUFFERING" value="3" enum="P2PSend">
		</constant>
		<constant name="P2P_SESSION_ERROR_NONE" value="0" enum="P2PSessionError">
		</constant>
		<constant name="P2P_SESSION_ERROR_NOT_RUNNING_APP" value="1" enum="P2PSessionError">
		</constant>
		<constant name="P2P_SESSION_ERROR_NO_RIGHTS_TO_APP" value="2" enum="P2PSessionError">
		</constant>
		<constant name="P2P_SESSION_ERROR_DESTINATION_NOT_LOGGED_ON" value="3" enum="P2PSessionError">
		</constant>
		<constant name="P2P_SESSION_ERROR_TIMEOUT" value="4" enum="P2PSessionError">
		</constant>
		<constant name="P2P_SESSION_ERROR_MAX" value="5" enum="P2PSessionError">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_NONE" value="0" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_WINDOWS" value="1" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_OSX" value="2" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_PS3" value="4" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_LINUX" value="8" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_SWITCH" value="16" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_ANDROID" value="32" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_IOS" value="64" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PLATFORM_ALL" value="4294967295" enum="RemoteStoragePlatform" is_bitfield="true">
		</constant>
		<constant name="REMOTE_STORAGE_PUBLISHED_VISIBILITY_PUBLIC" value="0" enum="RemoteStoragePublishedFileVisibility">
		</constant>
		<constant name="REMOTE_STORAGE_PUBLISHED_VISIBILITY_FRIENDS_ONLY" value="1" enum="RemoteStoragePublishedFileVisibility">
		</constant>
		<constant name="REMOTE_STORAGE_PUBLISHED_VISIBILITY_PRIVATE" value="2" enum="RemoteStoragePublishedFileVisibility">
		</constant>
		<constant name="REMOTE_STORAGE_PUBLISHED_VISIBILITY_UNLISTED" value="3" enum="RemoteStoragePublishedFileVisibility">
		</constant>
		<constant name="RESULT_NONE" value="0" enum="Result">
		</constant>
		<constant name="RESULT_OK" value="1" enum="Result">
		</constant>
		<constant name="RESULT_FAIL" value="2" enum="Result">
		</constant>
		<constant name="RESULT_NO_CONNECTION" value="3" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_PASSWORD" value="5" enum="Result">
		</constant>
		<constant name="RESULT_LOGGED_IN_ELSEWHERE" value="6" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_PROTOCOL_VER" value="7" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_PARAM" value="8" enum="Result">
		</constant>
		<constant name="RESULT_FILE_NOT_FOUND" value="9" enum="Result">
		</constant>
		<constant name="RESULT_BUSY" value="10" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_STATE" value="11" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_NAME" value="12" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_EMAIL" value="13" enum="Result">
		</constant>
		<constant name="RESULT_DUPLICATE_NAME" value="14" enum="Result">
		</constant>
		<constant name="RESULT_ACCESS_DENIED" value="15" enum="Result">
		</constant>
		<constant name="RESULT_TIMEOUT" value="16" enum="Result">
		</constant>
		<constant name="RESULT_BANNED" value="17" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_NOT_FOUND" value="18" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_STEAMID" value="19" enum="Result">
		</constant>
		<constant name="RESULT_SERVICE_UNAVAILABLE" value="20" enum="Result">
		</constant>
		<constant name="RESULT_NOT_LOGGED_ON" value="21" enum="Result">
		</constant>
		<constant name="RESULT_PENDING" value="22" enum="Result">
		</constant>
		<constant name="RESULT_ENCRYPTION_FAILURE" value="23" enum="Result">
		</constant>
		<constant name="RESULT_INSUFFICIENT_PRIVILEGE" value="24" enum="Result">
		</constant>
		<constant name="RESULT_LIMIT_EXCEEDED" value="25" enum="Result">
		</constant>
		<constant name="RESULT_REVOKED" value="26" enum="Result">
		</constant>
		<constant name="RESULT_EXPIRED" value="27" enum="Result">
		</constant>
		<constant name="RESULT_ALREADY_REDEEMED" value="28" enum="Result">
		</constant>
		<constant name="RESULT_DUPLICATE_REQUEST" value="29" enum="Result">
		</constant>
		<constant name="RESULT_ALREADY_OWNED" value="30" enum="Result">
		</constant>
		<constant name="RESULT_IP_NOT_FOUND" value="31" enum="Result">
		</constant>
		<constant name="RESULT_PERSIST_FAILED" value="32" enum="Result">
		</constant>
		<constant name="RESULT_LOCKING_FAILED" value="33" enum="Result">
		</constant>
		<constant name="RESULT_LOG_ON_SESSION_REPLACED" value="34" enum="Result">
		</constant>
		<constant name="RESULT_CONNECT_FAILED" value="35" enum="Result">
		</constant>
		<constant name="RESULT_HANDSHAKE_FAILED" value="36" enum="Result">
		</constant>
		<constant name="RESULT_IO_FAILURE" value="37" enum="Result">
		</constant>
		<constant name="RESULT_REMOTE_DISCONNECT" value="38" enum="Result">
		</constant>
		<constant name="RESULT_SHOPPING_CART_NOT_FOUND" value="39" enum="Result">
		</constant>
		<constant name="RESULT_BLOCKED" value="40" enum="Result">
		</constant>
		<constant name="RESULT_IGNORED" value="41" enum="Result">
		</constant>
		<constant name="RESULT_NO_MATCH" value="42" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_DISABLED" value="43" enum="Result">
		</constant>
		<constant name="RESULT_SERVICE_READ_ONLY" value="44" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_NOT_FEATURED" value="45" enum="Result">
		</constant>
		<constant name="RESULT_ADMINISTRATOR_OK" value="46" enum="Result">
		</constant>
		<constant name="RESULT_CONTENT_VERSION" value="47" enum="Result">
		</constant>
		<constant name="RESULT_TRY_ANOTHER_CM" value="48" enum="Result">
		</constant>
		<constant name="RESULT_PASSWORD_REQUIRED_TO_KICK_SESSION" value="49" enum="Result">
		</constant>
		<constant name="RESULT_ALREADY_LOGGED_IN_ELSEWHERE" value="50" enum="Result">
		</constant>
		<constant name="RESULT_SUSPENDED" value="51" enum="Result">
		</constant>
		<constant name="RESULT_CANCELLED" value="52" enum="Result">
		</constant>
		<constant name="RESULT_DATA_CORRUPTION" value="53" enum="Result">
		</constant>
		<constant name="RESULT_DISK_FULL" value="54" enum="Result">
		</constant>
		<constant name="RESULT_REMOTE_CALL_FAILED" value="55" enum="Result">
		</constant>
		<constant name="RESULT_PASSWORD_UNSET" value="56" enum="Result">
		</constant>
		<constant name="RESULT_EXTERNAL_ACCOUNT_UNLINKED" value="57" enum="Result">
		</constant>
		<constant name="RESULT_PSN_TICKET_INVALID" value="58" enum="Result">
		</constant>
		<constant name="RESULT_EXTERNAL_ACCOUNT_ALREADY_LINKED" value="59" enum="Result">
		</constant>
		<constant name="RESULT_REMOTE_FILE_CONFLICT" value="60" enum="Result">
		</constant>
		<constant name="RESULT_ILLEGAL_PASSWORD" value="61" enum="Result">
		</constant>
		<constant name="RESULT_SAME_AS_PREVIOUS_VALUE" value="62" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOG_ON_DENIED" value="63" enum="Result">
		</constant>
		<constant name="RESULT_CANNOT_USE_OLD_PASSWORD" value="64" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_LOG_IN_AUTH_CODE" value="65" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOG_ON_DENIED_NO_MAIL" value="66" enum="Result">
		</constant>
		<constant name="RESULT_HARDWARE_NOT_CAPABLE_OF_IPT" value="67" enum="Result">
		</constant>
		<constant name="RESULT_IPT_INIT_ERROR" value="68" enum="Result">
		</constant>
		<constant name="RESULT_PARENTAL_CONTROL_RESTRICTED" value="69" enum="Result">
		</constant>
		<constant name="RESULT_FACEBOOK_QUERY_ERROR" value="70" enum="Result">
		</constant>
		<constant name="RESULT_EXPIRED_LOGIN_AUTH_CODE" value="71" enum="Result">
		</constant>
		<constant name="RESULT_IP_LOGIN_RESTRICTION_FAILED" value="72" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOCKED_DOWN" value="73" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOG_ON_DENIED_VERIFIED_EMAIL_REQUIRED" value="74" enum="Result">
		</constant>
		<constant name="RESULT_NO_MATCHING_URL" value="75" enum="Result">
		</constant>
		<constant name="RESULT_BAD_RESPONSE" value="76" enum="Result">
		</constant>
		<constant name="RESULT_REQUIRE_PASSWORD_REENTRY" value="77" enum="Result">
		</constant>
		<constant name="RESULT_VALUE_OUT_OF_RANGE" value="78" enum="Result">
		</constant>
		<constant name="RESULT_UNEXPECTED_ERROR" value="79" enum="Result">
		</constant>
		<constant name="RESULT_DISABLED" value="80" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_CEG_SUBMISSION" value="81" enum="Result">
		</constant>
		<constant name="RESULT_RESTRICTED_DEVICE" value="82" enum="Result">
		</constant>
		<constant name="RESULT_REGION_LOCKED" value="83" enum="Result">
		</constant>
		<constant name="RESULT_RATE_LIMIT_EXCEEDED" value="84" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOGIN_DENIED_NEED_TWO_FACTOR" value="85" enum="Result">
		</constant>
		<constant name="RESULT_ITEM_DELETED" value="86" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LOGIN_DENIED_THROTTLE" value="87" enum="Result">
		</constant>
		<constant name="RESULT_TWO_FACTOR_CODE_MISMATCH" value="88" enum="Result">
		</constant>
		<constant name="RESULT_TWO_FACTOR_ACTIVATION_CODE_MISMATCH" value="89" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_ASSOCIATED_TO_MULTIPLE_PARTNERS" value="90" enum="Result">
		</constant>
		<constant name="RESULT_NOT_MODIFIED" value="91" enum="Result">
		</constant>
		<constant name="RESULT_NO_MOBILE_DEVICE" value="92" enum="Result">
		</constant>
		<constant name="RESULT_TIME_NOT_SYNCED" value="93" enum="Result">
		</constant>
		<constant name="RESULT_SMS_CODE_FAILED" value="94" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_LIMIT_EXCEEDED" value="95" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_ACTIVITY_LIMIT_EXCEEDED" value="96" enum="Result">
		</constant>
		<constant name="RESULT_PHONE_ACTIVITY_LIMIT_EXCEEDED" value="97" enum="Result">
		</constant>
		<constant name="RESULT_REFUND_TO_WALLET" value="98" enum="Result">
		</constant>
		<constant name="RESULT_EMAIL_SEND_FAILURE" value="99" enum="Result">
		</constant>
		<constant name="RESULT_NOT_SETTLED" value="100" enum="Result">
		</constant>
		<constant name="RESULT_NEED_CAPTCHA" value="101" enum="Result">
		</constant>
		<constant name="RESULT_GSLT_DENIED" value="102" enum="Result">
		</constant>
		<constant name="RESULT_GS_OWNER_DENIED" value="103" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_ITEM_TYPE" value="104" enum="Result">
		</constant>
		<constant name="RESULT_IP_BANNED" value="105" enum="Result">
		</constant>
		<constant name="RESULT_GSLT_EXPIRED" value="106" enum="Result">
		</constant>
		<constant name="RESULT_INSUFFICIENT_FUNDS" value="107" enum="Result">
		</constant>
		<constant name="RESULT_TOO_MANY_PENDING" value="108" enum="Result">
		</constant>
		<constant name="RESULT_NO_SITE_LICENSES_FOUND" value="109" enum="Result">
		</constant>
		<constant name="RESULT_WG_NETWORK_SEND_EXCEEDED" value="110" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_NOT_FRIENDS" value="111" enum="Result">
		</constant>
		<constant name="RESULT_LIMITED_USER_ACCOUNT" value="112" enum="Result">
		</constant>
		<constant name="RESULT_CANT_REMOVE_ITEM" value="113" enum="Result">
		</constant>
		<constant name="RESULT_ACCOUNT_DELETED" value="114" enum="Result">
		</constant>
		<constant name="RESULT_EXISTING_USER_CANCELLED_LICENSE" value="115" enum="Result">
		</constant>
		<constant name="RESULT_COMMUNITY_COOLDOWN" value="116" enum="Result">
		</constant>
		<constant name="RESULT_NO_LAUNCHER_SPECIFIED" value="117" enum="Result">
		</constant>
		<constant name="RESULT_MUST_AGREE_TO_SSA" value="118" enum="Result">
		</constant>
		<constant name="RESULT_LAUNCHER_MIGRATED" value="119" enum="Result">
		</constant>
		<constant name="RESULT_STEAM_REALM_MISMATCH" value="120" enum="Result">
		</constant>
		<constant name="RESULT_INVALID_SIGNATURE" value="121" enum="Result">
		</constant>
		<constant name="RESULT_PARSE_FAILURE" value="122" enum="Result">
		</constant>
		<constant name="RESULT_NO_VERIFIED_PHONE" value="123" enum="Result">
		</constant>
		<constant name="RESULT_INSUFFICIENT_BATTERY" value="124" enum="Result">
		</constant>
		<constant name="RESULT_CHARGER_REQUIRED" value="125" enum="Result">
		</constant>
		<constant name="RESULT_CACHED_CREDENTIAL_INVALID" value="126" enum="Result">
		</constant>
		<constant name="RESULT_PHONE_NUMBER_IS_VOIP" value="127" enum="Result">
		</constant>
		<constant name="RESULT_NOT_SUPPORTED" value="128" enum="Result">
		</constant>
		<constant name="RESULT_FAMILY_SIZE_LIMIT_EXCEEDED" value="129" enum="Result">
		</constant>
		<constant name="RESULT_OFFLINE_APP_CACHE_INVALID" value="130" enum="Result">
		</constant>
		<constant name="SERVER_MODE_INVALID" value="0" enum="ServerMode">
		</constant>
		<constant name="SERVER_MODE_NO_AUTHENTICATION" value="1" enum="ServerMode">
		</constant>
		<constant name="SERVER_MODE_AUTHENTICATION" value="2" enum="ServerMode">
		</constant>
		<constant name="SERVER_MODE_AUTHENTICATION_AND_SECURE" value="3" enum="ServerMode">
		</constant>
		<constant name="NET_SOCKET_CONNECTION_TYPE_NOT_CONNECTED" value="0" enum="SocketConnectionType">
		</constant>
		<constant name="NET_SOCKET_CONNECTION_TYPE_UDP" value="1" enum="SocketConnectionType">
		</constant>
		<constant name="NET_SOCKET_CONNECTION_TYPE_UDP_RELAY" value="2" enum="SocketConnectionType">
		</constant>
		<constant name="NET_SOCKET_STATE_INVALID" value="0" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_CONNECTED" value="1" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_INITIATED" value="10" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_LOCAL_CANDIDATE_FOUND" value="11" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_RECEIVED_REMOTE_CANDIDATES" value="12" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_CHALLENGE_HANDSHAKE" value="15" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_DISCONNECTING" value="21" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_LOCAL_DISCONNECT" value="22" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_TIMEOUT_DURING_CONNECT" value="23" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_REMOTE_END_DISCONNECTED" value="24" enum="SocketState">
		</constant>
		<constant name="NET_SOCKET_STATE_BROKEN" value="25" enum="SocketState">
		</constant>
		<constant name="STEAM_API_INIT_RESULT_OK" value="0" enum="SteamAPIInitResult">
		</constant>
		<constant name="STEAM_API_INIT_RESULT_FAILED_GENERIC" value="1" enum="SteamAPIInitResult">
		</constant>
		<constant name="STEAM_API_INIT_RESULT_NO_STEAM_CLIENT" value="2" enum="SteamAPIInitResult">
		</constant>
		<constant name="STEAM_API_INIT_RESULT_VERSION_MISMATCH" value="3" enum="SteamAPIInitResult">
		</constant>
		<constant name="UGC_CONTENT_DESCRIPTOR_NUDITY_OR_SEXUAL_CONTENT" value="1" enum="UGCContentDescriptorID">
		</constant>
		<constant name="UGC_CONTENT_DESCRIPTOR_FREQUENT_VIOLENCE_OR_GORE" value="2" enum="UGCContentDescriptorID">
		</constant>
		<constant name="UGC_CONTENT_DESCRIPTOR_ADULT_ONLY_SEXUAL_CONTENT" value="3" enum="UGCContentDescriptorID">
		</constant>
		<constant name="UGC_CONTENT_DESCRIPTOR_GRATUITOUS_SEXUAL_CONTENT" value="4" enum="UGCContentDescriptorID">
		</constant>
		<constant name="UGC_CONTENT_DESCRIPTOR_ANY_MATURE_CONTENT" value="5" enum="UGCContentDescriptorID">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ITEMS" value="0" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ITEMS_MTX" value="1" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ITEMS_READY_TO_USE" value="2" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_COLLECTIONS" value="3" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ARTWORK" value="4" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_VIDEOS" value="5" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_SCREENSHOTS" value="6" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ALL_GUIDES" value="7" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_WEB_GUIDES" value="8" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_INTEGRATED_GUIDES" value="9" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_USABLE_IN_GAME" value="10" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_CONTROLLER_BINDINGS" value="11" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_GAME_MANAGED_ITEMS" value="12" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_MATCHING_UGC_TYPE_ALL" value="-1" enum="UGCMatchingUGCType">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_VOTE" value="0" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_PUBLICATION_DATE" value="1" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_ACCEPTED_FOR_GAME_RANKED_BY_ACCEPTANCE_DATE" value="2" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_TREND" value="3" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_FAVORITED_BY_FRIENDS_RANKED_BY_PUBLICATION_DATE" value="4" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_CREATED_BY_FRIENDS_RANKED_BY_PUBLICATION_DATE" value="5" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_NUM_TIMES_REPORTED" value="6" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_CREATED_BY_FOLLOWED_USERS_RANKED_BY_PUBLICATION_DATE" value="7" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_NOT_YET_RATED" value="8" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_TOTAL_VOTES_ASC" value="9" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_VOTES_UP" value="10" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_TEXT_SEARCH" value="11" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_TOTAL_UNIQUE_SUBSCRIPTIONS" value="12" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_PLAYTIME_TREND" value="13" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_TOTAL_PLAYTIME" value="14" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_AVERAGE_PLAYTIME_TREND" value="15" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_LIFETIME_AVERAGE_PLAYTIME" value="16" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_PLAYTIME_SESSIONS_TREND" value="17" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_LIFETIME_PLAYTIME_SESSIONS" value="18" enum="UGCQuery">
		</constant>
		<constant name="UGC_QUERY_RANKED_BY_LAST_UPDATED_DATE" value="19" enum="UGCQuery">
		</constant>
		<constant name="UGC_READ_CONTINUE_READING_UNTIL_FINISHED" value="0" enum="UGCReadAction">
		</constant>
		<constant name="UGC_READ_CONTINUE_READING" value="1" enum="UGCReadAction">
		</constant>
		<constant name="UGC_READ_CLOSE" value="2" enum="UGCReadAction">
		</constant>
		<constant name="UNIVERSE_INVALID" value="0" enum="Universe">
		</constant>
		<constant name="UNIVERSE_PUBLIC" value="1" enum="Universe">
		</constant>
		<constant name="UNIVERSE_BETA" value="2" enum="Universe">
		</constant>
		<constant name="UNIVERSE_INTERNAL" value="3" enum="Universe">
		</constant>
		<constant name="UNIVERSE_DEV" value="4" enum="Universe">
		</constant>
		<constant name="UNIVERSE_MAX" value="5" enum="Universe">
		</constant>
		<constant name="USER_UGC_LIST_PUBLISHED" value="0" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_VOTED_ON" value="1" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_VOTED_UP" value="2" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_VOTED_DOWN" value="3" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_WILL_VOTE_LATER" value="4" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_FAVORITED" value="5" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_SUBSCRIBED" value="6" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_USED_OR_PLAYED" value="7" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_FOLLOWED" value="8" enum="UserUGCList">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_CREATION_ORDER_DESC" value="0" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_CREATION_ORDER_ASC" value="1" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_TITLE_ASC" value="2" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_LAST_UPDATED_DESC" value="3" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_SUBSCRIPTION_DATE_DESC" value="4" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_VOTE_SCORE_DESC" value="5" enum="UserUGCListSortOrder">
		</constant>
		<constant name="USER_UGC_LIST_SORT_ORDER_FOR_MODERATION" value="6" enum="UserUGCListSortOrder">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_RANKED_BY_VOTE" value="0" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_RECENT" value="1" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_TRENDING" value="2" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_FAVORITES_OF_FRIENDS" value="3" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_VOTED_BY_FRIENDS" value="4" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_CONTENT_BY_FRIENDS" value="5" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_ENUMERATION_TYPE_RECENT_FROM_FOLLOWED_USERS" value="6" enum="WorkshopEnumerationType">
		</constant>
		<constant name="WORKSHOP_FILE_ACTION_PLAYED" value="0" enum="WorkshopFileAction">
		</constant>
		<constant name="WORKSHOP_FILE_ACTION_COMPLETED" value="1" enum="WorkshopFileAction">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_FIRST" value="0" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_COMMUNITY" value="0" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_MICROTRANSACTION" value="1" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_COLLECTION" value="2" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_ART" value="3" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_VIDEO" value="4" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_SCREENSHOT" value="5" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_GAME" value="6" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_SOFTWARE" value="7" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_CONCEPT" value="8" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_WEB_GUIDE" value="9" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_INTEGRATED_GUIDE" value="10" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_MERCH" value="11" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_CONTROLLER_BINDING" value="12" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_STEAMWORKS_ACCESS_INVITE" value="13" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_STEAM_VIDEO" value="14" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_GAME_MANAGED_ITEM" value="15" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_CLIP" value="16" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_FILE_TYPE_MAX" value="17" enum="WorkshopFileType">
		</constant>
		<constant name="WORKSHOP_VIDEO_PROVIDER_NONE" value="0" enum="WorkshopVideoProvider">
		</constant>
		<constant name="WORKSHOP_VIDEO_PROVIDER_YOUTUBE" value="1" enum="WorkshopVideoProvider">
		</constant>
		<constant name="WORKSHOP_VOTE_UNVOTED" value="0" enum="WorkshopVote">
		</constant>
		<constant name="WORKSHOP_VOTE_FOR" value="1" enum="WorkshopVote">
		</constant>
		<constant name="WORKSHOP_VOTE_AGAINST" value="2" enum="WorkshopVote">
		</constant>
		<constant name="WORKSHOP_VOTE_LATER" value="3" enum="WorkshopVote">
		</constant>
	</constants>
</class>
